/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.0.v202012010850.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_COM_QUALCOMM_QTI_LOCATION_Location_Types_HPP_
#define V1_COM_QUALCOMM_QTI_LOCATION_Location_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v1 {
namespace com {
namespace qualcomm {
namespace qti {
namespace location {

struct LocationTypes {
    
    struct MapMatchingFeedbackDataValidityT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            MMFDVT_INVALID = 0,
            MMFDVT_UTC_TIME = 1,
            MMFDVT_LAT_DIFF = 2,
            MMFDVT_LONG_DIFF = 4,
            MMFDVT_TUNNEL = 8,
            MMFDVT_BEARING = 16,
            MMFDVT_ALTITUDE = 32,
            MMFDVT_HOR_ACC = 64,
            MMFDVT_ALT_ACC = 128,
            MMFDVT_BEARING_ACC = 256
        };
    
        MapMatchingFeedbackDataValidityT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::MMFDVT_INVALID)) {}
        MapMatchingFeedbackDataValidityT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::MMFDVT_INVALID):
                case static_cast< uint32_t>(Literal::MMFDVT_UTC_TIME):
                case static_cast< uint32_t>(Literal::MMFDVT_LAT_DIFF):
                case static_cast< uint32_t>(Literal::MMFDVT_LONG_DIFF):
                case static_cast< uint32_t>(Literal::MMFDVT_TUNNEL):
                case static_cast< uint32_t>(Literal::MMFDVT_BEARING):
                case static_cast< uint32_t>(Literal::MMFDVT_ALTITUDE):
                case static_cast< uint32_t>(Literal::MMFDVT_HOR_ACC):
                case static_cast< uint32_t>(Literal::MMFDVT_ALT_ACC):
                case static_cast< uint32_t>(Literal::MMFDVT_BEARING_ACC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapMatchingFeedbackDataValidityT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::MMFDVT_INVALID): return "MMFDVT_INVALID";
            case static_cast< uint32_t>(Literal::MMFDVT_UTC_TIME): return "MMFDVT_UTC_TIME";
            case static_cast< uint32_t>(Literal::MMFDVT_LAT_DIFF): return "MMFDVT_LAT_DIFF";
            case static_cast< uint32_t>(Literal::MMFDVT_LONG_DIFF): return "MMFDVT_LONG_DIFF";
            case static_cast< uint32_t>(Literal::MMFDVT_TUNNEL): return "MMFDVT_TUNNEL";
            case static_cast< uint32_t>(Literal::MMFDVT_BEARING): return "MMFDVT_BEARING";
            case static_cast< uint32_t>(Literal::MMFDVT_ALTITUDE): return "MMFDVT_ALTITUDE";
            case static_cast< uint32_t>(Literal::MMFDVT_HOR_ACC): return "MMFDVT_HOR_ACC";
            case static_cast< uint32_t>(Literal::MMFDVT_ALT_ACC): return "MMFDVT_ALT_ACC";
            case static_cast< uint32_t>(Literal::MMFDVT_BEARING_ACC): return "MMFDVT_BEARING_ACC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssReportCbInfoMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GRCIMT_UNKNOWN = 0,
            GRCIMT_LOCATION_CB_INFO_BIT = 1,
            GRCIMT_SV_CB_INFO_BIT = 2,
            GRCIMT_NMEA_CB_INFO_BIT = 4,
            GRCIMT_DATA_CB_INFO_BIT = 8,
            GRCIMT_MEAS_CB_INFO_BIT = 16
        };
    
        GnssReportCbInfoMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GRCIMT_UNKNOWN)) {}
        GnssReportCbInfoMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GRCIMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GRCIMT_LOCATION_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::GRCIMT_SV_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::GRCIMT_NMEA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::GRCIMT_DATA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::GRCIMT_MEAS_CB_INFO_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssReportCbInfoMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssReportCbInfoMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssReportCbInfoMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssReportCbInfoMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssReportCbInfoMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssReportCbInfoMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GRCIMT_UNKNOWN): return "GRCIMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GRCIMT_LOCATION_CB_INFO_BIT): return "GRCIMT_LOCATION_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::GRCIMT_SV_CB_INFO_BIT): return "GRCIMT_SV_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::GRCIMT_NMEA_CB_INFO_BIT): return "GRCIMT_NMEA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::GRCIMT_DATA_CB_INFO_BIT): return "GRCIMT_DATA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::GRCIMT_MEAS_CB_INFO_BIT): return "GRCIMT_MEAS_CB_INFO_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationStatusT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            LOCATION_STATUS_T_UNKNOWN = 0,
            LOCATION_STATUS_T_SUCCESS = 1,
            LOCATION_STATUS_T_UNKOWN_FAILURE = 2,
            LOCATION_STATUS_T_NOT_SUPPORTED = 3,
            LOCATION_STATUS_T_PARAM_INVALID = 4,
            LOCATION_STATUS_T_TIMEOUT = 5,
            LOCATION_STATUS_T_REQUEST_ALREADY_IN_PROGRESS = 6,
            LOCATION_STATUS_T_SYSTEM_NOT_READY = 7,
            LOCATION_STATUS_T_EXCLUSIVE_SESSION_IN_PROGRESS = 8
        };
    
        LocationStatusT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::LOCATION_STATUS_T_UNKNOWN)) {}
        LocationStatusT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_UNKNOWN):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_SUCCESS):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_UNKOWN_FAILURE):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_NOT_SUPPORTED):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_PARAM_INVALID):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_TIMEOUT):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_REQUEST_ALREADY_IN_PROGRESS):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_SYSTEM_NOT_READY):
                case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_EXCLUSIVE_SESSION_IN_PROGRESS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationStatusT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationStatusT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationStatusT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationStatusT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationStatusT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationStatusT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_UNKNOWN): return "LOCATION_STATUS_T_UNKNOWN";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_SUCCESS): return "LOCATION_STATUS_T_SUCCESS";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_UNKOWN_FAILURE): return "LOCATION_STATUS_T_UNKOWN_FAILURE";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_NOT_SUPPORTED): return "LOCATION_STATUS_T_NOT_SUPPORTED";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_PARAM_INVALID): return "LOCATION_STATUS_T_PARAM_INVALID";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_TIMEOUT): return "LOCATION_STATUS_T_TIMEOUT";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_REQUEST_ALREADY_IN_PROGRESS): return "LOCATION_STATUS_T_REQUEST_ALREADY_IN_PROGRESS";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_SYSTEM_NOT_READY): return "LOCATION_STATUS_T_SYSTEM_NOT_READY";
            case static_cast< uint8_t>(Literal::LOCATION_STATUS_T_EXCLUSIVE_SESSION_IN_PROGRESS): return "LOCATION_STATUS_T_EXCLUSIVE_SESSION_IN_PROGRESS";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocReqEngineTypeMaskT : CommonAPI::Enumeration< uint16_t> {
        enum Literal : uint16_t {
            LRETM_UNKNOWN = 0,
            LRETM_FUSED = 1,
            LRETM_SPE = 2,
            LRETM_PPE = 4,
            LRETM_VPE = 8
        };
    
        LocReqEngineTypeMaskT()
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(Literal::LRETM_UNKNOWN)) {}
        LocReqEngineTypeMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint16_t>(Literal::LRETM_UNKNOWN):
                case static_cast< uint16_t>(Literal::LRETM_FUSED):
                case static_cast< uint16_t>(Literal::LRETM_SPE):
                case static_cast< uint16_t>(Literal::LRETM_PPE):
                case static_cast< uint16_t>(Literal::LRETM_VPE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocReqEngineTypeMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocReqEngineTypeMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocReqEngineTypeMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocReqEngineTypeMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocReqEngineTypeMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocReqEngineTypeMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint16_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint16_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint16_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint16_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint16_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint16_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint16_t>(Literal::LRETM_UNKNOWN): return "LRETM_UNKNOWN";
            case static_cast< uint16_t>(Literal::LRETM_FUSED): return "LRETM_FUSED";
            case static_cast< uint16_t>(Literal::LRETM_SPE): return "LRETM_SPE";
            case static_cast< uint16_t>(Literal::LRETM_PPE): return "LRETM_PPE";
            case static_cast< uint16_t>(Literal::LRETM_VPE): return "LRETM_VPE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct EngineReportCbMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            ERCMT_LOCATION_CB_INFO_UNKNOWN = 0,
            ERCMT_LOCATION_CB_INFO_BIT = 1,
            ERCMT_SV_CB_INFO_BIT = 2,
            ERCMT_NMEA_CB_INFO_BIT = 4,
            ERCMT_DATA_CB_INFO_BIT = 8,
            ERCMT_MEAS_CB_INFO_BIT = 16,
            ERCMT_ENGINE_NMEA_CB_INFO_BIT = 32
        };
    
        EngineReportCbMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::ERCMT_LOCATION_CB_INFO_UNKNOWN)) {}
        EngineReportCbMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::ERCMT_LOCATION_CB_INFO_UNKNOWN):
                case static_cast< uint32_t>(Literal::ERCMT_LOCATION_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::ERCMT_SV_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::ERCMT_NMEA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::ERCMT_DATA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::ERCMT_MEAS_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::ERCMT_ENGINE_NMEA_CB_INFO_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const EngineReportCbMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const EngineReportCbMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const EngineReportCbMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const EngineReportCbMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const EngineReportCbMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const EngineReportCbMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::ERCMT_LOCATION_CB_INFO_UNKNOWN): return "ERCMT_LOCATION_CB_INFO_UNKNOWN";
            case static_cast< uint32_t>(Literal::ERCMT_LOCATION_CB_INFO_BIT): return "ERCMT_LOCATION_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::ERCMT_SV_CB_INFO_BIT): return "ERCMT_SV_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::ERCMT_NMEA_CB_INFO_BIT): return "ERCMT_NMEA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::ERCMT_DATA_CB_INFO_BIT): return "ERCMT_DATA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::ERCMT_MEAS_CB_INFO_BIT): return "ERCMT_MEAS_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::ERCMT_ENGINE_NMEA_CB_INFO_BIT): return "ERCMT_ENGINE_NMEA_CB_INFO_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct AidingDataDeletionMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            ADDMT_UNKNOWN = 0,
            ADDMT_ALL = 1,
            ADDMT_EPHEMERIS = 2,
            ADDMT_DR_SENSOR_CALIBRATION = 4
        };
    
        AidingDataDeletionMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::ADDMT_UNKNOWN)) {}
        AidingDataDeletionMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::ADDMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::ADDMT_ALL):
                case static_cast< uint32_t>(Literal::ADDMT_EPHEMERIS):
                case static_cast< uint32_t>(Literal::ADDMT_DR_SENSOR_CALIBRATION):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AidingDataDeletionMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AidingDataDeletionMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AidingDataDeletionMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AidingDataDeletionMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AidingDataDeletionMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AidingDataDeletionMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::ADDMT_UNKNOWN): return "ADDMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::ADDMT_ALL): return "ADDMT_ALL";
            case static_cast< uint32_t>(Literal::ADDMT_EPHEMERIS): return "ADDMT_EPHEMERIS";
            case static_cast< uint32_t>(Literal::ADDMT_DR_SENSOR_CALIBRATION): return "ADDMT_DR_SENSOR_CALIBRATION";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssConstellationTypeT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            GCTT_UNKNOWN = 0,
            GCTT_GLONASS = 1,
            GCTT_QZSS = 2,
            GCTT_BEIDOU = 3,
            GCTT_GALILEO = 4,
            GCTT_SBAS = 5,
            GCTT_NAVIC = 6,
            GCTT_GPS = 7,
            GCTT_MAX = 7
        };
    
        GnssConstellationTypeT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::GCTT_UNKNOWN)) {}
        GnssConstellationTypeT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::GCTT_UNKNOWN):
                case static_cast< uint8_t>(Literal::GCTT_GLONASS):
                case static_cast< uint8_t>(Literal::GCTT_QZSS):
                case static_cast< uint8_t>(Literal::GCTT_BEIDOU):
                case static_cast< uint8_t>(Literal::GCTT_GALILEO):
                case static_cast< uint8_t>(Literal::GCTT_SBAS):
                case static_cast< uint8_t>(Literal::GCTT_NAVIC):
                case static_cast< uint8_t>(Literal::GCTT_GPS):
                //case static_cast< uint8_t>(Literal::GCTT_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssConstellationTypeT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssConstellationTypeT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssConstellationTypeT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssConstellationTypeT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssConstellationTypeT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssConstellationTypeT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::GCTT_UNKNOWN): return "GCTT_UNKNOWN";
            case static_cast< uint8_t>(Literal::GCTT_GLONASS): return "GCTT_GLONASS";
            case static_cast< uint8_t>(Literal::GCTT_QZSS): return "GCTT_QZSS";
            case static_cast< uint8_t>(Literal::GCTT_BEIDOU): return "GCTT_BEIDOU";
            case static_cast< uint8_t>(Literal::GCTT_GALILEO): return "GCTT_GALILEO";
            case static_cast< uint8_t>(Literal::GCTT_SBAS): return "GCTT_SBAS";
            case static_cast< uint8_t>(Literal::GCTT_NAVIC): return "GCTT_NAVIC";
            case static_cast< uint8_t>(Literal::GCTT_GPS): return "GCTT_GPS";
            //case static_cast< uint8_t>(Literal::GCTT_MAX): return "GCTT_MAX";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationCapabilitiesMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LCMT_UNKNOWN = 0,
            LCMT_TIME_BASED_TRACKING_BIT = 1,
            LCMT_GNSS_MEAS_BIT = 2
        };
    
        LocationCapabilitiesMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LCMT_UNKNOWN)) {}
        LocationCapabilitiesMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LCMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LCMT_TIME_BASED_TRACKING_BIT):
                case static_cast< uint32_t>(Literal::LCMT_GNSS_MEAS_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationCapabilitiesMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationCapabilitiesMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationCapabilitiesMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationCapabilitiesMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationCapabilitiesMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationCapabilitiesMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LCMT_UNKNOWN): return "LCMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LCMT_TIME_BASED_TRACKING_BIT): return "LCMT_TIME_BASED_TRACKING_BIT";
            case static_cast< uint32_t>(Literal::LCMT_GNSS_MEAS_BIT): return "LCMT_GNSS_MEAS_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssMeasurementsClockFlagsMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GMCFMT_UNKNOWN = 0,
            GMCFMT_LEAP_SECOND_BIT = 1,
            GMCFMT_TIME_BIT = 2,
            GMCFMT_TIME_UNCERTAINTY_BIT = 4,
            GMCFMT_FULL_BIAS_BIT = 8,
            GMCFMT_BIAS_BIT = 16,
            GMCFMT_BIAS_UNCERTAINTY_BIT = 32,
            GMCFMT_DRIFT_BIT = 64,
            GMCFMT_DRIFT_UNCERTAINTY_BIT = 128,
            GMCFMT_HW_CLOCK_DISCONTINUITY_COUNT_BIT = 256,
            GMCFMT_ELAPSED_REAL_TIME_BIT = 512,
            GMCFMT_ELAPSED_REAL_TIME_UNC_BIT = 1024,
            GMCFMT_ELAPSED_GPTP_TIME_BIT = 2048,
            GMCFMT_ELAPSED_GPTP_TIME_UNC_BIT = 4096
        };
    
        GnssMeasurementsClockFlagsMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GMCFMT_UNKNOWN)) {}
        GnssMeasurementsClockFlagsMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GMCFMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GMCFMT_LEAP_SECOND_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_TIME_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_TIME_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_FULL_BIAS_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_BIAS_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_BIAS_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_DRIFT_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_DRIFT_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_HW_CLOCK_DISCONTINUITY_COUNT_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_REAL_TIME_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_REAL_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_GPTP_TIME_BIT):
                case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_GPTP_TIME_UNC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssMeasurementsClockFlagsMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GMCFMT_UNKNOWN): return "GMCFMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GMCFMT_LEAP_SECOND_BIT): return "GMCFMT_LEAP_SECOND_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_TIME_BIT): return "GMCFMT_TIME_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_TIME_UNCERTAINTY_BIT): return "GMCFMT_TIME_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_FULL_BIAS_BIT): return "GMCFMT_FULL_BIAS_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_BIAS_BIT): return "GMCFMT_BIAS_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_BIAS_UNCERTAINTY_BIT): return "GMCFMT_BIAS_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_DRIFT_BIT): return "GMCFMT_DRIFT_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_DRIFT_UNCERTAINTY_BIT): return "GMCFMT_DRIFT_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_HW_CLOCK_DISCONTINUITY_COUNT_BIT): return "GMCFMT_HW_CLOCK_DISCONTINUITY_COUNT_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_REAL_TIME_BIT): return "GMCFMT_ELAPSED_REAL_TIME_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_REAL_TIME_UNC_BIT): return "GMCFMT_ELAPSED_REAL_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_GPTP_TIME_BIT): return "GMCFMT_ELAPSED_GPTP_TIME_BIT";
            case static_cast< uint32_t>(Literal::GMCFMT_ELAPSED_GPTP_TIME_UNC_BIT): return "GMCFMT_ELAPSED_GPTP_TIME_UNC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssMeasurementsDataFlagsMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GMDFMT_UNKNOWN = 0,
            GMDFMT_SV_ID_BIT = 1,
            GMDFMT_SV_TYPE_BIT = 2,
            GMDFMT_STATE_BIT = 4,
            GMDFMT_RECEIVED_SV_TIME_BIT = 8,
            GMDFMT_RECVD_SV_TIME_UNC_BIT = 16,
            GMDFMT_CARRIER_TO_NOISE_BIT = 32,
            GMDFMT_PR_RATE_BIT = 64,
            GMDFMT_PR_RATE_UNC_BIT = 128,
            GMDFMT_ADR_STATE_BIT = 256,
            GMDFMT_ADR_BIT = 512,
            GMDFMT_ADR_UNC_BIT = 1024,
            GMDFMT_CARRIER_FREQ_BIT = 2048,
            GMDFMT_CARRIER_CYCLES_BIT = 4096,
            GMDFMT_CARRIER_PHASE_BIT = 8192,
            GMDFMT_CARRIER_PHASE_UNC_BIT = 16384,
            GMDFMT_MULTIPATH_IND_BIT = 32768,
            GMDFMT_SIGNAL_TO_NOISE_RATIO = 65536,
            GMDFMT_AUTO_GAIN_CTRL_BIT = 131072,
            GMDFMT_FULL_ISB_BIT = 262144,
            GMDFMT_FULL_ISB_UNC_BIT = 524288,
            GMDFMT_CYCLE_SLIP_COUNT_BIT = 1048576,
            GMDFMT_GNSS_SIGNAL_TYPE_BIT = 2097152,
            GMDFMT_BASEBAND_CARRIER_TO_NOISE_BIT = 4194304
        };
    
        GnssMeasurementsDataFlagsMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GMDFMT_UNKNOWN)) {}
        GnssMeasurementsDataFlagsMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GMDFMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GMDFMT_SV_ID_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_SV_TYPE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_STATE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_RECEIVED_SV_TIME_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_RECVD_SV_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_TO_NOISE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_PR_RATE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_PR_RATE_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_ADR_STATE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_ADR_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_ADR_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_FREQ_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_CYCLES_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_PHASE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_PHASE_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_MULTIPATH_IND_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_SIGNAL_TO_NOISE_RATIO):
                case static_cast< uint32_t>(Literal::GMDFMT_AUTO_GAIN_CTRL_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_FULL_ISB_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_FULL_ISB_UNC_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_CYCLE_SLIP_COUNT_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_GNSS_SIGNAL_TYPE_BIT):
                case static_cast< uint32_t>(Literal::GMDFMT_BASEBAND_CARRIER_TO_NOISE_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssMeasurementsDataFlagsMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GMDFMT_UNKNOWN): return "GMDFMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GMDFMT_SV_ID_BIT): return "GMDFMT_SV_ID_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_SV_TYPE_BIT): return "GMDFMT_SV_TYPE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_STATE_BIT): return "GMDFMT_STATE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_RECEIVED_SV_TIME_BIT): return "GMDFMT_RECEIVED_SV_TIME_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_RECVD_SV_TIME_UNC_BIT): return "GMDFMT_RECVD_SV_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_TO_NOISE_BIT): return "GMDFMT_CARRIER_TO_NOISE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_PR_RATE_BIT): return "GMDFMT_PR_RATE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_PR_RATE_UNC_BIT): return "GMDFMT_PR_RATE_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_ADR_STATE_BIT): return "GMDFMT_ADR_STATE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_ADR_BIT): return "GMDFMT_ADR_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_ADR_UNC_BIT): return "GMDFMT_ADR_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_FREQ_BIT): return "GMDFMT_CARRIER_FREQ_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_CYCLES_BIT): return "GMDFMT_CARRIER_CYCLES_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_PHASE_BIT): return "GMDFMT_CARRIER_PHASE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CARRIER_PHASE_UNC_BIT): return "GMDFMT_CARRIER_PHASE_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_MULTIPATH_IND_BIT): return "GMDFMT_MULTIPATH_IND_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_SIGNAL_TO_NOISE_RATIO): return "GMDFMT_SIGNAL_TO_NOISE_RATIO";
            case static_cast< uint32_t>(Literal::GMDFMT_AUTO_GAIN_CTRL_BIT): return "GMDFMT_AUTO_GAIN_CTRL_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_FULL_ISB_BIT): return "GMDFMT_FULL_ISB_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_FULL_ISB_UNC_BIT): return "GMDFMT_FULL_ISB_UNC_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_CYCLE_SLIP_COUNT_BIT): return "GMDFMT_CYCLE_SLIP_COUNT_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_GNSS_SIGNAL_TYPE_BIT): return "GMDFMT_GNSS_SIGNAL_TYPE_BIT";
            case static_cast< uint32_t>(Literal::GMDFMT_BASEBAND_CARRIER_TO_NOISE_BIT): return "GMDFMT_BASEBAND_CARRIER_TO_NOISE_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssSvTypeT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            GNSS_SV_TYPE_T_UNKNOWN = 0,
            GNSS_SV_TYPE_T_GPS = 1,
            GNSS_SV_TYPE_T_SBAS = 2,
            GNSS_SV_TYPE_T_GLONASS = 3,
            GNSS_SV_TYPE_T_QZSS = 4,
            GNSS_SV_TYPE_T_BEIDOU = 5,
            GNSS_SV_TYPE_T_GALILEO = 6,
            GNSS_SV_TYPE_T_NAVIC = 7
        };
    
        GnssSvTypeT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_UNKNOWN)) {}
        GnssSvTypeT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_UNKNOWN):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GPS):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_SBAS):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GLONASS):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_QZSS):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_BEIDOU):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GALILEO):
                case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_NAVIC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssSvTypeT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssSvTypeT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssSvTypeT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssSvTypeT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssSvTypeT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssSvTypeT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_UNKNOWN): return "GNSS_SV_TYPE_T_UNKNOWN";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GPS): return "GNSS_SV_TYPE_T_GPS";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_SBAS): return "GNSS_SV_TYPE_T_SBAS";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GLONASS): return "GNSS_SV_TYPE_T_GLONASS";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_QZSS): return "GNSS_SV_TYPE_T_QZSS";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_BEIDOU): return "GNSS_SV_TYPE_T_BEIDOU";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_GALILEO): return "GNSS_SV_TYPE_T_GALILEO";
            case static_cast< uint8_t>(Literal::GNSS_SV_TYPE_T_NAVIC): return "GNSS_SV_TYPE_T_NAVIC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssMeasurementsStateMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GMSMT_UNKNOWN = 0,
            GMSMT_CODE_LOCK = 1,
            GMSMT_BIT_SYNC = 2,
            GMSMT_SUBFRAME_SYNC = 4,
            GMSMT_TOW_DECODED = 8,
            GMSMT_MSEC_AMBIGUOUS = 16,
            GMSMT_SYMBOL_SYNC = 32,
            GMSMT_GLO_STRING_SYNC = 64,
            GMSMT_GLO_TOD_DECODED = 128,
            GMSMT_BDS_D2_BIT_SYNC = 256,
            GMSMT_BDS_D2_SUBFRAME_SYNC = 512,
            GMSMT_GAL_E1BC_CODE_LOCK = 1024,
            GMSMT_GAL_E1C_2ND_CODE_LOCK = 2048,
            GMSMT_GAL_E1B_PAGE_SYNC = 4096,
            GMSMT_SBAS_SYNC = 8192
        };
    
        GnssMeasurementsStateMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GMSMT_UNKNOWN)) {}
        GnssMeasurementsStateMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GMSMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GMSMT_CODE_LOCK):
                case static_cast< uint32_t>(Literal::GMSMT_BIT_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_SUBFRAME_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_TOW_DECODED):
                case static_cast< uint32_t>(Literal::GMSMT_MSEC_AMBIGUOUS):
                case static_cast< uint32_t>(Literal::GMSMT_SYMBOL_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_GLO_STRING_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_GLO_TOD_DECODED):
                case static_cast< uint32_t>(Literal::GMSMT_BDS_D2_BIT_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_BDS_D2_SUBFRAME_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_GAL_E1BC_CODE_LOCK):
                case static_cast< uint32_t>(Literal::GMSMT_GAL_E1C_2ND_CODE_LOCK):
                case static_cast< uint32_t>(Literal::GMSMT_GAL_E1B_PAGE_SYNC):
                case static_cast< uint32_t>(Literal::GMSMT_SBAS_SYNC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssMeasurementsStateMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssMeasurementsStateMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssMeasurementsStateMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssMeasurementsStateMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssMeasurementsStateMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssMeasurementsStateMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GMSMT_UNKNOWN): return "GMSMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GMSMT_CODE_LOCK): return "GMSMT_CODE_LOCK";
            case static_cast< uint32_t>(Literal::GMSMT_BIT_SYNC): return "GMSMT_BIT_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_SUBFRAME_SYNC): return "GMSMT_SUBFRAME_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_TOW_DECODED): return "GMSMT_TOW_DECODED";
            case static_cast< uint32_t>(Literal::GMSMT_MSEC_AMBIGUOUS): return "GMSMT_MSEC_AMBIGUOUS";
            case static_cast< uint32_t>(Literal::GMSMT_SYMBOL_SYNC): return "GMSMT_SYMBOL_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_GLO_STRING_SYNC): return "GMSMT_GLO_STRING_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_GLO_TOD_DECODED): return "GMSMT_GLO_TOD_DECODED";
            case static_cast< uint32_t>(Literal::GMSMT_BDS_D2_BIT_SYNC): return "GMSMT_BDS_D2_BIT_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_BDS_D2_SUBFRAME_SYNC): return "GMSMT_BDS_D2_SUBFRAME_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_GAL_E1BC_CODE_LOCK): return "GMSMT_GAL_E1BC_CODE_LOCK";
            case static_cast< uint32_t>(Literal::GMSMT_GAL_E1C_2ND_CODE_LOCK): return "GMSMT_GAL_E1C_2ND_CODE_LOCK";
            case static_cast< uint32_t>(Literal::GMSMT_GAL_E1B_PAGE_SYNC): return "GMSMT_GAL_E1B_PAGE_SYNC";
            case static_cast< uint32_t>(Literal::GMSMT_SBAS_SYNC): return "GMSMT_SBAS_SYNC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssMeasurementsAdrStateMaskT : CommonAPI::Enumeration< uint16_t> {
        enum Literal : uint16_t {
            GMASMT_STATE_UNKNOWN = 0,
            GMASMT_STATE_VALID_BIT = 1,
            GMASMT_STATE_RESET_BIT = 2,
            GMASMT_STATE_CYCLE_SLIP_BIT = 4,
            GMASMT_STATE_HALF_CYCLE_RESOLVED_BIT = 8
        };
    
        GnssMeasurementsAdrStateMaskT()
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(Literal::GMASMT_STATE_UNKNOWN)) {}
        GnssMeasurementsAdrStateMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint16_t>(Literal::GMASMT_STATE_UNKNOWN):
                case static_cast< uint16_t>(Literal::GMASMT_STATE_VALID_BIT):
                case static_cast< uint16_t>(Literal::GMASMT_STATE_RESET_BIT):
                case static_cast< uint16_t>(Literal::GMASMT_STATE_CYCLE_SLIP_BIT):
                case static_cast< uint16_t>(Literal::GMASMT_STATE_HALF_CYCLE_RESOLVED_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssMeasurementsAdrStateMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint16_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint16_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint16_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint16_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint16_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint16_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint16_t>(Literal::GMASMT_STATE_UNKNOWN): return "GMASMT_STATE_UNKNOWN";
            case static_cast< uint16_t>(Literal::GMASMT_STATE_VALID_BIT): return "GMASMT_STATE_VALID_BIT";
            case static_cast< uint16_t>(Literal::GMASMT_STATE_RESET_BIT): return "GMASMT_STATE_RESET_BIT";
            case static_cast< uint16_t>(Literal::GMASMT_STATE_CYCLE_SLIP_BIT): return "GMASMT_STATE_CYCLE_SLIP_BIT";
            case static_cast< uint16_t>(Literal::GMASMT_STATE_HALF_CYCLE_RESOLVED_BIT): return "GMASMT_STATE_HALF_CYCLE_RESOLVED_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssMeasurementsMultipathIndicatorT : CommonAPI::Enumeration< uint16_t> {
        enum Literal : uint16_t {
            GMMIT_UNKNOWN = 0,
            GMMIT_PRESENT = 1,
            GMMIT_NOT_PRESENT = 2
        };
    
        GnssMeasurementsMultipathIndicatorT()
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(Literal::GMMIT_UNKNOWN)) {}
        GnssMeasurementsMultipathIndicatorT(Literal _literal)
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint16_t>(Literal::GMMIT_UNKNOWN):
                case static_cast< uint16_t>(Literal::GMMIT_PRESENT):
                case static_cast< uint16_t>(Literal::GMMIT_NOT_PRESENT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssMeasurementsMultipathIndicatorT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint16_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint16_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint16_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint16_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint16_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint16_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint16_t>(Literal::GMMIT_UNKNOWN): return "GMMIT_UNKNOWN";
            case static_cast< uint16_t>(Literal::GMMIT_PRESENT): return "GMMIT_PRESENT";
            case static_cast< uint16_t>(Literal::GMMIT_NOT_PRESENT): return "GMMIT_NOT_PRESENT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssSignalTypeT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GSTT_UNKNOWN = 0,
            GSTT_GPS_L1CA_BIT = 1,
            GSTT_GPS_L1C_BIT = 2,
            GSTT_GPS_L2_BIT = 3,
            GSTT_GPS_L5_BIT = 4,
            GSTT_GLONASS_G1_BIT = 5,
            GSTT_GLONASS_G2_BIT = 6,
            GSTT_GALILEO_E1_BIT = 7,
            GSTT_GALILEO_E5A_BIT = 8,
            GSTT_GALILEO_E5B_BIT = 9,
            GSTT_BEIDOU_B1_BIT = 10,
            GSTT_BEIDOU_B2_BIT = 11,
            GSTT_QZSS_L1CA_BIT = 12,
            GSTT_QZSS_L1S_BIT = 13,
            GSTT_QZSS_L2_BIT = 14,
            GSTT_QZSS_L5_BIT = 15,
            GSTT_SBAS_L1_BIT = 16,
            GSTT_BEIDOU_B1I_BIT = 17,
            GSTT_BEIDOU_B1C_BIT = 18,
            GSTT_BEIDOU_B2I_BIT = 19,
            GSTT_BEIDOU_B2AI_BIT = 20,
            GSTT_NAVIC_L5_BIT = 21,
            GSTT_BEIDOU_B2AQ_BIT = 22,
            GSTT_BEIDOU_B2BI_BIT = 23,
            GSTT_BEIDOU_B2BQ_BIT = 24,
            GSTT_NAVIC_L1_BIT = 25,
            GSTT_MAX_NUMBER_OF_SIGNAL_TYPES = 25
        };
    
        GnssSignalTypeT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GSTT_UNKNOWN)) {}
        GnssSignalTypeT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GSTT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GSTT_GPS_L1CA_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GPS_L1C_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GPS_L2_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GPS_L5_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GLONASS_G1_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GLONASS_G2_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GALILEO_E1_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GALILEO_E5A_BIT):
                case static_cast< uint32_t>(Literal::GSTT_GALILEO_E5B_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2_BIT):
                case static_cast< uint32_t>(Literal::GSTT_QZSS_L1CA_BIT):
                case static_cast< uint32_t>(Literal::GSTT_QZSS_L1S_BIT):
                case static_cast< uint32_t>(Literal::GSTT_QZSS_L2_BIT):
                case static_cast< uint32_t>(Literal::GSTT_QZSS_L5_BIT):
                case static_cast< uint32_t>(Literal::GSTT_SBAS_L1_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1I_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1C_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2I_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2AI_BIT):
                case static_cast< uint32_t>(Literal::GSTT_NAVIC_L5_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2AQ_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2BI_BIT):
                case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2BQ_BIT):
                case static_cast< uint32_t>(Literal::GSTT_NAVIC_L1_BIT):
                //case static_cast< uint32_t>(Literal::GSTT_MAX_NUMBER_OF_SIGNAL_TYPES):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssSignalTypeT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssSignalTypeT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssSignalTypeT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssSignalTypeT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssSignalTypeT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssSignalTypeT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GSTT_UNKNOWN): return "GSTT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GSTT_GPS_L1CA_BIT): return "GSTT_GPS_L1CA_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GPS_L1C_BIT): return "GSTT_GPS_L1C_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GPS_L2_BIT): return "GSTT_GPS_L2_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GPS_L5_BIT): return "GSTT_GPS_L5_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GLONASS_G1_BIT): return "GSTT_GLONASS_G1_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GLONASS_G2_BIT): return "GSTT_GLONASS_G2_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GALILEO_E1_BIT): return "GSTT_GALILEO_E1_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GALILEO_E5A_BIT): return "GSTT_GALILEO_E5A_BIT";
            case static_cast< uint32_t>(Literal::GSTT_GALILEO_E5B_BIT): return "GSTT_GALILEO_E5B_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1_BIT): return "GSTT_BEIDOU_B1_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2_BIT): return "GSTT_BEIDOU_B2_BIT";
            case static_cast< uint32_t>(Literal::GSTT_QZSS_L1CA_BIT): return "GSTT_QZSS_L1CA_BIT";
            case static_cast< uint32_t>(Literal::GSTT_QZSS_L1S_BIT): return "GSTT_QZSS_L1S_BIT";
            case static_cast< uint32_t>(Literal::GSTT_QZSS_L2_BIT): return "GSTT_QZSS_L2_BIT";
            case static_cast< uint32_t>(Literal::GSTT_QZSS_L5_BIT): return "GSTT_QZSS_L5_BIT";
            case static_cast< uint32_t>(Literal::GSTT_SBAS_L1_BIT): return "GSTT_SBAS_L1_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1I_BIT): return "GSTT_BEIDOU_B1I_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B1C_BIT): return "GSTT_BEIDOU_B1C_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2I_BIT): return "GSTT_BEIDOU_B2I_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2AI_BIT): return "GSTT_BEIDOU_B2AI_BIT";
            case static_cast< uint32_t>(Literal::GSTT_NAVIC_L5_BIT): return "GSTT_NAVIC_L5_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2AQ_BIT): return "GSTT_BEIDOU_B2AQ_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2BI_BIT): return "GSTT_BEIDOU_B2BI_BIT";
            case static_cast< uint32_t>(Literal::GSTT_BEIDOU_B2BQ_BIT): return "GSTT_BEIDOU_B2BQ_BIT";
            case static_cast< uint32_t>(Literal::GSTT_NAVIC_L1_BIT): return "GSTT_NAVIC_L1_BIT";
            //case static_cast< uint32_t>(Literal::GSTT_MAX_NUMBER_OF_SIGNAL_TYPES): return "GSTT_MAX_NUMBER_OF_SIGNAL_TYPES";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationFlagsMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LFMT_UNKNOWN = 0,
            LFMT_HAS_LAT_LONG_BIT = 1,
            LFMT_HAS_ALTITUDE_BIT = 2,
            LFMT_HAS_SPEED_BIT = 4,
            LFMT_HAS_BEARING_BIT = 8,
            LFMT_HAS_ACCURACY_BIT = 16,
            LFMT_HAS_VERTICAL_ACCURACY_BIT = 32,
            LFMT_HAS_SPEED_ACCURACY_BIT = 64,
            LFMT_HAS_BEARING_ACCURACY_BIT = 128,
            LFMT_HAS_TIMESTAMP_BIT = 256,
            LFMT_HAS_ELAPSED_REAL_TIME_BIT = 512,
            LFMT_ELAPSED_REAL_TIME_UNC_BIT = 1024,
            LFMT_HAS_TIME_UNC_BIT = 2048,
            LFMT_HAS_ELAPSED_PTP_TIME_BIT = 4096
        };
    
        LocationFlagsMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LFMT_UNKNOWN)) {}
        LocationFlagsMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LFMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LFMT_HAS_LAT_LONG_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_ALTITUDE_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_SPEED_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_BEARING_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_VERTICAL_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_SPEED_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_BEARING_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_TIMESTAMP_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_ELAPSED_REAL_TIME_BIT):
                case static_cast< uint32_t>(Literal::LFMT_ELAPSED_REAL_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::LFMT_HAS_ELAPSED_PTP_TIME_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationFlagsMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationFlagsMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationFlagsMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationFlagsMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationFlagsMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationFlagsMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LFMT_UNKNOWN): return "LFMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LFMT_HAS_LAT_LONG_BIT): return "LFMT_HAS_LAT_LONG_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_ALTITUDE_BIT): return "LFMT_HAS_ALTITUDE_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_SPEED_BIT): return "LFMT_HAS_SPEED_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_BEARING_BIT): return "LFMT_HAS_BEARING_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_ACCURACY_BIT): return "LFMT_HAS_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_VERTICAL_ACCURACY_BIT): return "LFMT_HAS_VERTICAL_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_SPEED_ACCURACY_BIT): return "LFMT_HAS_SPEED_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_BEARING_ACCURACY_BIT): return "LFMT_HAS_BEARING_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_TIMESTAMP_BIT): return "LFMT_HAS_TIMESTAMP_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_ELAPSED_REAL_TIME_BIT): return "LFMT_HAS_ELAPSED_REAL_TIME_BIT";
            case static_cast< uint32_t>(Literal::LFMT_ELAPSED_REAL_TIME_UNC_BIT): return "LFMT_ELAPSED_REAL_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_TIME_UNC_BIT): return "LFMT_HAS_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::LFMT_HAS_ELAPSED_PTP_TIME_BIT): return "LFMT_HAS_ELAPSED_PTP_TIME_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationTechnologyMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LTMT_UNKNOWN = 0,
            LTMT_GNSS_BIT = 1,
            LTMT_CELL_BIT = 2,
            LTMT_WIFI_BIT = 4,
            LTMT_SENSORS_BIT = 8,
            LTMT_REF_LOC_BIT = 16,
            LTMT_INJECTED_COARSE_POS_BIT = 32,
            LTMT_AFLT_BIT = 64,
            LTMT_HYBRID_BIT = 128,
            LTMT_PPE_BIT = 256,
            LTMT_VEH_BIT = 512,
            LTMT_VIS_BIT = 1024,
            LTMT_PROPAGATED_BIT = 2048
        };
    
        LocationTechnologyMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LTMT_UNKNOWN)) {}
        LocationTechnologyMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LTMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LTMT_GNSS_BIT):
                case static_cast< uint32_t>(Literal::LTMT_CELL_BIT):
                case static_cast< uint32_t>(Literal::LTMT_WIFI_BIT):
                case static_cast< uint32_t>(Literal::LTMT_SENSORS_BIT):
                case static_cast< uint32_t>(Literal::LTMT_REF_LOC_BIT):
                case static_cast< uint32_t>(Literal::LTMT_INJECTED_COARSE_POS_BIT):
                case static_cast< uint32_t>(Literal::LTMT_AFLT_BIT):
                case static_cast< uint32_t>(Literal::LTMT_HYBRID_BIT):
                case static_cast< uint32_t>(Literal::LTMT_PPE_BIT):
                case static_cast< uint32_t>(Literal::LTMT_VEH_BIT):
                case static_cast< uint32_t>(Literal::LTMT_VIS_BIT):
                case static_cast< uint32_t>(Literal::LTMT_PROPAGATED_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationTechnologyMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationTechnologyMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationTechnologyMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationTechnologyMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationTechnologyMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationTechnologyMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LTMT_UNKNOWN): return "LTMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LTMT_GNSS_BIT): return "LTMT_GNSS_BIT";
            case static_cast< uint32_t>(Literal::LTMT_CELL_BIT): return "LTMT_CELL_BIT";
            case static_cast< uint32_t>(Literal::LTMT_WIFI_BIT): return "LTMT_WIFI_BIT";
            case static_cast< uint32_t>(Literal::LTMT_SENSORS_BIT): return "LTMT_SENSORS_BIT";
            case static_cast< uint32_t>(Literal::LTMT_REF_LOC_BIT): return "LTMT_REF_LOC_BIT";
            case static_cast< uint32_t>(Literal::LTMT_INJECTED_COARSE_POS_BIT): return "LTMT_INJECTED_COARSE_POS_BIT";
            case static_cast< uint32_t>(Literal::LTMT_AFLT_BIT): return "LTMT_AFLT_BIT";
            case static_cast< uint32_t>(Literal::LTMT_HYBRID_BIT): return "LTMT_HYBRID_BIT";
            case static_cast< uint32_t>(Literal::LTMT_PPE_BIT): return "LTMT_PPE_BIT";
            case static_cast< uint32_t>(Literal::LTMT_VEH_BIT): return "LTMT_VEH_BIT";
            case static_cast< uint32_t>(Literal::LTMT_VIS_BIT): return "LTMT_VIS_BIT";
            case static_cast< uint32_t>(Literal::LTMT_PROPAGATED_BIT): return "LTMT_PROPAGATED_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationReportFlagMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LRFMT_UNKNOWN = 0,
            LRFMT_ALTITUDE_MEAN_SEA_LEVEL = 1,
            LRFMT_DOP = 2,
            LRFMT_MAGNETIC_DEVIATION = 4,
            LRFMT_HOR_RELIABILITY = 8,
            LRFMT_VER_RELIABILITY = 16,
            LRFMT_HOR_ACCURACY_ELIP_SEMI_MAJOR = 32,
            LRFMT_HOR_ACCURACY_ELIP_SEMI_MINOR = 64,
            LRFMT_HOR_ACCURACY_ELIP_AZIMUTH = 128,
            LRFMT_GNSS_SV_USED_DATA = 256,
            LRFMT_NAV_SOLUTION_MASK_BIT = 512,
            LRFMT_GNSS_LOCATION_INFO_POS_TECH_MASK = 1024,
            LRFMT_POS_DYNAMICS_DATA = 2048,
            LRFMT_EXT_DOP = 4096,
            LRFMT_NORTH_STD_DEV = 8192,
            LRFMT_EAST_STD_DEV = 16384,
            LRFMT_NORTH_VEL = 32768,
            LRFMT_EAST_VEL = 65536,
            LRFMT_UP_VEL = 131072,
            LRFMT_NORTH_VEL_UNC = 262144,
            LRFMT_EAST_VEL_UNC = 524288,
            LRFMT_UP_VEL_UNC = 1048576,
            LRFMT_LEAP_SECONDS = 2097152,
            LRFMT_NUM_SV_USED_IN_POS = 4194304,
            LRFMT_CALIB_CONFIDENCE_PERCENT = 8388608,
            LRFMT_CALIB_STATUS = 16777216,
            LRFMT_OUTPUT_ENG_TYPE = 33554432,
            LRFMT_OUTPUT_ENG_MASK = 67108864,
            LRFMT_CONFORMITY_INDEX = 134217728,
            LRFMT_LLA_VRP_BASED = 268435456,
            LRFMT_ENU_VEL_VRP_BASED = 536870912,
            LRFMT_DR_SOL_STATUS_MASK = 1073741824
        };
    
        LocationReportFlagMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LRFMT_UNKNOWN)) {}
        LocationReportFlagMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LRFMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LRFMT_ALTITUDE_MEAN_SEA_LEVEL):
                case static_cast< uint32_t>(Literal::LRFMT_DOP):
                case static_cast< uint32_t>(Literal::LRFMT_MAGNETIC_DEVIATION):
                case static_cast< uint32_t>(Literal::LRFMT_HOR_RELIABILITY):
                case static_cast< uint32_t>(Literal::LRFMT_VER_RELIABILITY):
                case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_SEMI_MAJOR):
                case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_SEMI_MINOR):
                case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_AZIMUTH):
                case static_cast< uint32_t>(Literal::LRFMT_GNSS_SV_USED_DATA):
                case static_cast< uint32_t>(Literal::LRFMT_NAV_SOLUTION_MASK_BIT):
                case static_cast< uint32_t>(Literal::LRFMT_GNSS_LOCATION_INFO_POS_TECH_MASK):
                case static_cast< uint32_t>(Literal::LRFMT_POS_DYNAMICS_DATA):
                case static_cast< uint32_t>(Literal::LRFMT_EXT_DOP):
                case static_cast< uint32_t>(Literal::LRFMT_NORTH_STD_DEV):
                case static_cast< uint32_t>(Literal::LRFMT_EAST_STD_DEV):
                case static_cast< uint32_t>(Literal::LRFMT_NORTH_VEL):
                case static_cast< uint32_t>(Literal::LRFMT_EAST_VEL):
                case static_cast< uint32_t>(Literal::LRFMT_UP_VEL):
                case static_cast< uint32_t>(Literal::LRFMT_NORTH_VEL_UNC):
                case static_cast< uint32_t>(Literal::LRFMT_EAST_VEL_UNC):
                case static_cast< uint32_t>(Literal::LRFMT_UP_VEL_UNC):
                case static_cast< uint32_t>(Literal::LRFMT_LEAP_SECONDS):
                case static_cast< uint32_t>(Literal::LRFMT_NUM_SV_USED_IN_POS):
                case static_cast< uint32_t>(Literal::LRFMT_CALIB_CONFIDENCE_PERCENT):
                case static_cast< uint32_t>(Literal::LRFMT_CALIB_STATUS):
                case static_cast< uint32_t>(Literal::LRFMT_OUTPUT_ENG_TYPE):
                case static_cast< uint32_t>(Literal::LRFMT_OUTPUT_ENG_MASK):
                case static_cast< uint32_t>(Literal::LRFMT_CONFORMITY_INDEX):
                case static_cast< uint32_t>(Literal::LRFMT_LLA_VRP_BASED):
                case static_cast< uint32_t>(Literal::LRFMT_ENU_VEL_VRP_BASED):
                case static_cast< uint32_t>(Literal::LRFMT_DR_SOL_STATUS_MASK):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationReportFlagMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationReportFlagMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationReportFlagMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationReportFlagMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationReportFlagMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationReportFlagMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LRFMT_UNKNOWN): return "LRFMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LRFMT_ALTITUDE_MEAN_SEA_LEVEL): return "LRFMT_ALTITUDE_MEAN_SEA_LEVEL";
            case static_cast< uint32_t>(Literal::LRFMT_DOP): return "LRFMT_DOP";
            case static_cast< uint32_t>(Literal::LRFMT_MAGNETIC_DEVIATION): return "LRFMT_MAGNETIC_DEVIATION";
            case static_cast< uint32_t>(Literal::LRFMT_HOR_RELIABILITY): return "LRFMT_HOR_RELIABILITY";
            case static_cast< uint32_t>(Literal::LRFMT_VER_RELIABILITY): return "LRFMT_VER_RELIABILITY";
            case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_SEMI_MAJOR): return "LRFMT_HOR_ACCURACY_ELIP_SEMI_MAJOR";
            case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_SEMI_MINOR): return "LRFMT_HOR_ACCURACY_ELIP_SEMI_MINOR";
            case static_cast< uint32_t>(Literal::LRFMT_HOR_ACCURACY_ELIP_AZIMUTH): return "LRFMT_HOR_ACCURACY_ELIP_AZIMUTH";
            case static_cast< uint32_t>(Literal::LRFMT_GNSS_SV_USED_DATA): return "LRFMT_GNSS_SV_USED_DATA";
            case static_cast< uint32_t>(Literal::LRFMT_NAV_SOLUTION_MASK_BIT): return "LRFMT_NAV_SOLUTION_MASK_BIT";
            case static_cast< uint32_t>(Literal::LRFMT_GNSS_LOCATION_INFO_POS_TECH_MASK): return "LRFMT_GNSS_LOCATION_INFO_POS_TECH_MASK";
            case static_cast< uint32_t>(Literal::LRFMT_POS_DYNAMICS_DATA): return "LRFMT_POS_DYNAMICS_DATA";
            case static_cast< uint32_t>(Literal::LRFMT_EXT_DOP): return "LRFMT_EXT_DOP";
            case static_cast< uint32_t>(Literal::LRFMT_NORTH_STD_DEV): return "LRFMT_NORTH_STD_DEV";
            case static_cast< uint32_t>(Literal::LRFMT_EAST_STD_DEV): return "LRFMT_EAST_STD_DEV";
            case static_cast< uint32_t>(Literal::LRFMT_NORTH_VEL): return "LRFMT_NORTH_VEL";
            case static_cast< uint32_t>(Literal::LRFMT_EAST_VEL): return "LRFMT_EAST_VEL";
            case static_cast< uint32_t>(Literal::LRFMT_UP_VEL): return "LRFMT_UP_VEL";
            case static_cast< uint32_t>(Literal::LRFMT_NORTH_VEL_UNC): return "LRFMT_NORTH_VEL_UNC";
            case static_cast< uint32_t>(Literal::LRFMT_EAST_VEL_UNC): return "LRFMT_EAST_VEL_UNC";
            case static_cast< uint32_t>(Literal::LRFMT_UP_VEL_UNC): return "LRFMT_UP_VEL_UNC";
            case static_cast< uint32_t>(Literal::LRFMT_LEAP_SECONDS): return "LRFMT_LEAP_SECONDS";
            case static_cast< uint32_t>(Literal::LRFMT_NUM_SV_USED_IN_POS): return "LRFMT_NUM_SV_USED_IN_POS";
            case static_cast< uint32_t>(Literal::LRFMT_CALIB_CONFIDENCE_PERCENT): return "LRFMT_CALIB_CONFIDENCE_PERCENT";
            case static_cast< uint32_t>(Literal::LRFMT_CALIB_STATUS): return "LRFMT_CALIB_STATUS";
            case static_cast< uint32_t>(Literal::LRFMT_OUTPUT_ENG_TYPE): return "LRFMT_OUTPUT_ENG_TYPE";
            case static_cast< uint32_t>(Literal::LRFMT_OUTPUT_ENG_MASK): return "LRFMT_OUTPUT_ENG_MASK";
            case static_cast< uint32_t>(Literal::LRFMT_CONFORMITY_INDEX): return "LRFMT_CONFORMITY_INDEX";
            case static_cast< uint32_t>(Literal::LRFMT_LLA_VRP_BASED): return "LRFMT_LLA_VRP_BASED";
            case static_cast< uint32_t>(Literal::LRFMT_ENU_VEL_VRP_BASED): return "LRFMT_ENU_VEL_VRP_BASED";
            case static_cast< uint32_t>(Literal::LRFMT_DR_SOL_STATUS_MASK): return "LRFMT_DR_SOL_STATUS_MASK";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationReliabilityT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            LOCATION_RELIABILIT_T_NOT_SET = 0,
            LOCATION_RELIABILIT_T_VERY_LOW = 1,
            LOCATION_RELIABILIT_T_LOW = 2,
            LOCATION_RELIABILIT_T_MEDIUM = 3,
            LOCATION_RELIABILIT_T_HIGH = 4
        };
    
        LocationReliabilityT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_NOT_SET)) {}
        LocationReliabilityT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_NOT_SET):
                case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_VERY_LOW):
                case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_LOW):
                case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_MEDIUM):
                case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_HIGH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationReliabilityT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationReliabilityT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationReliabilityT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationReliabilityT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationReliabilityT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationReliabilityT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_NOT_SET): return "LOCATION_RELIABILIT_T_NOT_SET";
            case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_VERY_LOW): return "LOCATION_RELIABILIT_T_VERY_LOW";
            case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_LOW): return "LOCATION_RELIABILIT_T_LOW";
            case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_MEDIUM): return "LOCATION_RELIABILIT_T_MEDIUM";
            case static_cast< uint8_t>(Literal::LOCATION_RELIABILIT_T_HIGH): return "LOCATION_RELIABILIT_T_HIGH";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationReportNavSolutionMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LRNSMT_UNKNOWN = 0,
            LRNSMT_SBAS_CORR_IONO = 1,
            LRNSMT_SBAS_CORR_FAST = 2,
            LRNSMT_SBAS_CORR_LONG = 4,
            LRNSMT_SBAS_INTEGRITY = 8,
            LRNSMT_NAV_CORR_DGNSS = 16,
            LRNSMT_NAV_CORR_RTK = 32,
            LRNSMT_NAV_CORR_PPP = 64,
            LRNSMT_NAV_CORR_RTK_FIX = 128,
            LRNSMT_NAV_CORR_ONLY_SBAS_CORR_SV_USED = 256,
            LRNSMT_NAV_CORR_MMF_AIDED = 512
        };
    
        LocationReportNavSolutionMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LRNSMT_UNKNOWN)) {}
        LocationReportNavSolutionMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LRNSMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_IONO):
                case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_FAST):
                case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_LONG):
                case static_cast< uint32_t>(Literal::LRNSMT_SBAS_INTEGRITY):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_DGNSS):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_RTK):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_PPP):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_RTK_FIX):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_ONLY_SBAS_CORR_SV_USED):
                case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_MMF_AIDED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationReportNavSolutionMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationReportNavSolutionMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationReportNavSolutionMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationReportNavSolutionMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationReportNavSolutionMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationReportNavSolutionMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LRNSMT_UNKNOWN): return "LRNSMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_IONO): return "LRNSMT_SBAS_CORR_IONO";
            case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_FAST): return "LRNSMT_SBAS_CORR_FAST";
            case static_cast< uint32_t>(Literal::LRNSMT_SBAS_CORR_LONG): return "LRNSMT_SBAS_CORR_LONG";
            case static_cast< uint32_t>(Literal::LRNSMT_SBAS_INTEGRITY): return "LRNSMT_SBAS_INTEGRITY";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_DGNSS): return "LRNSMT_NAV_CORR_DGNSS";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_RTK): return "LRNSMT_NAV_CORR_RTK";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_PPP): return "LRNSMT_NAV_CORR_PPP";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_RTK_FIX): return "LRNSMT_NAV_CORR_RTK_FIX";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_ONLY_SBAS_CORR_SV_USED): return "LRNSMT_NAV_CORR_ONLY_SBAS_CORR_SV_USED";
            case static_cast< uint32_t>(Literal::LRNSMT_NAV_CORR_MMF_AIDED): return "LRNSMT_NAV_CORR_MMF_AIDED";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationReportPosDataMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LRPDMT_UNKNOWN = 0,
            LRPDMT_NAV_DATA_LONG_ACCEL = 1,
            LRPDMT_NAV_DATA_LAT_ACCEL = 2,
            LRPDMT_NAV_DATA_VERT_ACCEL = 4,
            LRPDMT_NAV_DATA_YAW_RATE = 8,
            LRPDMT_NAV_DATA_PITCH = 16,
            LRPDMT_NAV_DATA_LONG_ACCEL_UNC = 32,
            LRPDMT_NAV_DATA_LAT_ACCEL_UNC = 64,
            LRPDMT_NAV_DATA_VERT_ACCEL_UNC = 128,
            LRPDMT_NAV_DATA_YAW_RATE_UNC = 256,
            LRPDMT_NAV_DATA_PITCH_UNC = 512,
            LRPDMT_NAV_DATA_PITCH_RATE = 1024,
            LRPDMT_NAV_DATA_PITCH_RATE_UNC = 2048,
            LRPDMT_NAV_DATA_ROLL = 4096,
            LRPDMT_NAV_DATA_ROLL_UNC = 8192,
            LRPDMT_NAV_DATA_ROLL_RATE = 16384,
            LRPDMT_NAV_DATA_ROLL_RATE_UNC = 32768,
            LRPDMT_NAV_DATA_YAW = 65536,
            LRPDMT_NAV_DATA_YAW_UNC = 131072
        };
    
        LocationReportPosDataMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LRPDMT_UNKNOWN)) {}
        LocationReportPosDataMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LRPDMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LONG_ACCEL):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LAT_ACCEL):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_VERT_ACCEL):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_RATE):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LONG_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LAT_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_VERT_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_RATE_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_RATE):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_RATE_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_RATE):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_RATE_UNC):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW):
                case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_UNC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationReportPosDataMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationReportPosDataMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationReportPosDataMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationReportPosDataMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationReportPosDataMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationReportPosDataMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LRPDMT_UNKNOWN): return "LRPDMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LONG_ACCEL): return "LRPDMT_NAV_DATA_LONG_ACCEL";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LAT_ACCEL): return "LRPDMT_NAV_DATA_LAT_ACCEL";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_VERT_ACCEL): return "LRPDMT_NAV_DATA_VERT_ACCEL";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_RATE): return "LRPDMT_NAV_DATA_YAW_RATE";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH): return "LRPDMT_NAV_DATA_PITCH";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LONG_ACCEL_UNC): return "LRPDMT_NAV_DATA_LONG_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_LAT_ACCEL_UNC): return "LRPDMT_NAV_DATA_LAT_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_VERT_ACCEL_UNC): return "LRPDMT_NAV_DATA_VERT_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_RATE_UNC): return "LRPDMT_NAV_DATA_YAW_RATE_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_UNC): return "LRPDMT_NAV_DATA_PITCH_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_RATE): return "LRPDMT_NAV_DATA_PITCH_RATE";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_PITCH_RATE_UNC): return "LRPDMT_NAV_DATA_PITCH_RATE_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL): return "LRPDMT_NAV_DATA_ROLL";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_UNC): return "LRPDMT_NAV_DATA_ROLL_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_RATE): return "LRPDMT_NAV_DATA_ROLL_RATE";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_ROLL_RATE_UNC): return "LRPDMT_NAV_DATA_ROLL_RATE_UNC";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW): return "LRPDMT_NAV_DATA_YAW";
            case static_cast< uint32_t>(Literal::LRPDMT_NAV_DATA_YAW_UNC): return "LRPDMT_NAV_DATA_YAW_UNC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssLocSvSystemTypeT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            GLSSTT_UNKNOWN = 0,
            GLSSTT_GPS = 1,
            GLSSTT_GAL = 2,
            GLSSTT_SBAS = 3,
            GLSSTT_GLO = 4,
            GLSSTT_BDS = 5,
            GLSSTT_QZSS = 6,
            GLSSTT_NAVIC = 7
        };
    
        GnssLocSvSystemTypeT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::GLSSTT_UNKNOWN)) {}
        GnssLocSvSystemTypeT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::GLSSTT_UNKNOWN):
                case static_cast< uint8_t>(Literal::GLSSTT_GPS):
                case static_cast< uint8_t>(Literal::GLSSTT_GAL):
                case static_cast< uint8_t>(Literal::GLSSTT_SBAS):
                case static_cast< uint8_t>(Literal::GLSSTT_GLO):
                case static_cast< uint8_t>(Literal::GLSSTT_BDS):
                case static_cast< uint8_t>(Literal::GLSSTT_QZSS):
                case static_cast< uint8_t>(Literal::GLSSTT_NAVIC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssLocSvSystemTypeT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssLocSvSystemTypeT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssLocSvSystemTypeT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssLocSvSystemTypeT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssLocSvSystemTypeT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssLocSvSystemTypeT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::GLSSTT_UNKNOWN): return "GLSSTT_UNKNOWN";
            case static_cast< uint8_t>(Literal::GLSSTT_GPS): return "GLSSTT_GPS";
            case static_cast< uint8_t>(Literal::GLSSTT_GAL): return "GLSSTT_GAL";
            case static_cast< uint8_t>(Literal::GLSSTT_SBAS): return "GLSSTT_SBAS";
            case static_cast< uint8_t>(Literal::GLSSTT_GLO): return "GLSSTT_GLO";
            case static_cast< uint8_t>(Literal::GLSSTT_BDS): return "GLSSTT_BDS";
            case static_cast< uint8_t>(Literal::GLSSTT_QZSS): return "GLSSTT_QZSS";
            case static_cast< uint8_t>(Literal::GLSSTT_NAVIC): return "GLSSTT_NAVIC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssSystemTimeStructTypeFlagsT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GSTSTFT_INVALID = 0,
            GSTSTFT_WEEK_VALID = 1,
            GSTSTFT_WEEK_MS_VALID = 2,
            GSTSTFT_CLK_TIME_BIAS_VALID = 4,
            GSTSTFT_CLK_TIME_BIAS_UNC_VALID = 8,
            GSTSTFT_REF_FCOUNT_VALID = 16,
            GSTSTFT_NUM_CLOCK_RESETS_VALID = 32
        };
    
        GnssSystemTimeStructTypeFlagsT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GSTSTFT_INVALID)) {}
        GnssSystemTimeStructTypeFlagsT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GSTSTFT_INVALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_WEEK_VALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_WEEK_MS_VALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_CLK_TIME_BIAS_VALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_CLK_TIME_BIAS_UNC_VALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_REF_FCOUNT_VALID):
                case static_cast< uint32_t>(Literal::GSTSTFT_NUM_CLOCK_RESETS_VALID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssSystemTimeStructTypeFlagsT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GSTSTFT_INVALID): return "GSTSTFT_INVALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_WEEK_VALID): return "GSTSTFT_WEEK_VALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_WEEK_MS_VALID): return "GSTSTFT_WEEK_MS_VALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_CLK_TIME_BIAS_VALID): return "GSTSTFT_CLK_TIME_BIAS_VALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_CLK_TIME_BIAS_UNC_VALID): return "GSTSTFT_CLK_TIME_BIAS_UNC_VALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_REF_FCOUNT_VALID): return "GSTSTFT_REF_FCOUNT_VALID";
            case static_cast< uint32_t>(Literal::GSTSTFT_NUM_CLOCK_RESETS_VALID): return "GSTSTFT_NUM_CLOCK_RESETS_VALID";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssGloTimeStructTypeFlagsT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GGTSTFT_INVALID = 0,
            GGTSTFT_DAYS_VALID = 1,
            GGTSTFT_MSEC_VALID = 2,
            GGTSTFT_CLK_TIME_BIAS_VALID = 4,
            GGTSTFT_CLK_TIME_BIAS_UNC_VALID = 8,
            GGTSTFT_REF_FCOUNT_VALID = 16,
            GGTSTFT_NUM_CLK_RESETS_VALID = 32,
            GGTSTFT_FOUR_YEAR_VALID = 64
        };
    
        GnssGloTimeStructTypeFlagsT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GGTSTFT_INVALID)) {}
        GnssGloTimeStructTypeFlagsT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GGTSTFT_INVALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_DAYS_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_MSEC_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_CLK_TIME_BIAS_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_CLK_TIME_BIAS_UNC_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_REF_FCOUNT_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_NUM_CLK_RESETS_VALID):
                case static_cast< uint32_t>(Literal::GGTSTFT_FOUR_YEAR_VALID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssGloTimeStructTypeFlagsT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GGTSTFT_INVALID): return "GGTSTFT_INVALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_DAYS_VALID): return "GGTSTFT_DAYS_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_MSEC_VALID): return "GGTSTFT_MSEC_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_CLK_TIME_BIAS_VALID): return "GGTSTFT_CLK_TIME_BIAS_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_CLK_TIME_BIAS_UNC_VALID): return "GGTSTFT_CLK_TIME_BIAS_UNC_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_REF_FCOUNT_VALID): return "GGTSTFT_REF_FCOUNT_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_NUM_CLK_RESETS_VALID): return "GGTSTFT_NUM_CLK_RESETS_VALID";
            case static_cast< uint32_t>(Literal::GGTSTFT_FOUR_YEAR_VALID): return "GGTSTFT_FOUR_YEAR_VALID";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DrCalibrationStatusMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            DCSMT_UNKNOWN = 0,
            DCSMT_ROLL_CALIB_NEEDED = 1,
            DCSMT_PITCH_CALIB_NEEDED = 2,
            DCSMT_YAW_CALIB_NEEDED = 4,
            DCSMT_ODO_CALIB_NEEDED = 8,
            DCSMT_GYRO_CALIB_NEEDED = 16,
            DCSMT_TURN_CALIB_LOW = 32,
            DCSMT_TURN_CALIB_MED = 64,
            DCSMT_TURN_CALIB_HIGH = 128,
            DCSMT_LINEAR_ACCEL_CALIB_LOW = 256,
            DCSMT_LINEAR_ACCEL_CALIB_MED = 512,
            DCSMT_LINEAR_ACCEL_CALIB_HIGH = 1024,
            DCSMT_LINEAR_MOTION_CALIB_LOW = 2048,
            DCSMT_LINEAR_MOTION_CALIB_MED = 4096,
            DCSMT_LINEAR_MOTION_CALIB_HIGH = 8192,
            DCSMT_STATIC_CALIB_LOW = 16384,
            DCSMT_STATIC_CALIB_MED = 32768,
            DCSMT_STATIC_CALIB_HIGH = 65536
        };
    
        DrCalibrationStatusMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::DCSMT_UNKNOWN)) {}
        DrCalibrationStatusMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::DCSMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::DCSMT_ROLL_CALIB_NEEDED):
                case static_cast< uint32_t>(Literal::DCSMT_PITCH_CALIB_NEEDED):
                case static_cast< uint32_t>(Literal::DCSMT_YAW_CALIB_NEEDED):
                case static_cast< uint32_t>(Literal::DCSMT_ODO_CALIB_NEEDED):
                case static_cast< uint32_t>(Literal::DCSMT_GYRO_CALIB_NEEDED):
                case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_LOW):
                case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_MED):
                case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_HIGH):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_LOW):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_MED):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_HIGH):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_LOW):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_MED):
                case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_HIGH):
                case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_LOW):
                case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_MED):
                case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_HIGH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DrCalibrationStatusMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DrCalibrationStatusMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DrCalibrationStatusMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DrCalibrationStatusMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DrCalibrationStatusMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DrCalibrationStatusMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::DCSMT_UNKNOWN): return "DCSMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::DCSMT_ROLL_CALIB_NEEDED): return "DCSMT_ROLL_CALIB_NEEDED";
            case static_cast< uint32_t>(Literal::DCSMT_PITCH_CALIB_NEEDED): return "DCSMT_PITCH_CALIB_NEEDED";
            case static_cast< uint32_t>(Literal::DCSMT_YAW_CALIB_NEEDED): return "DCSMT_YAW_CALIB_NEEDED";
            case static_cast< uint32_t>(Literal::DCSMT_ODO_CALIB_NEEDED): return "DCSMT_ODO_CALIB_NEEDED";
            case static_cast< uint32_t>(Literal::DCSMT_GYRO_CALIB_NEEDED): return "DCSMT_GYRO_CALIB_NEEDED";
            case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_LOW): return "DCSMT_TURN_CALIB_LOW";
            case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_MED): return "DCSMT_TURN_CALIB_MED";
            case static_cast< uint32_t>(Literal::DCSMT_TURN_CALIB_HIGH): return "DCSMT_TURN_CALIB_HIGH";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_LOW): return "DCSMT_LINEAR_ACCEL_CALIB_LOW";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_MED): return "DCSMT_LINEAR_ACCEL_CALIB_MED";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_ACCEL_CALIB_HIGH): return "DCSMT_LINEAR_ACCEL_CALIB_HIGH";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_LOW): return "DCSMT_LINEAR_MOTION_CALIB_LOW";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_MED): return "DCSMT_LINEAR_MOTION_CALIB_MED";
            case static_cast< uint32_t>(Literal::DCSMT_LINEAR_MOTION_CALIB_HIGH): return "DCSMT_LINEAR_MOTION_CALIB_HIGH";
            case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_LOW): return "DCSMT_STATIC_CALIB_LOW";
            case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_MED): return "DCSMT_STATIC_CALIB_MED";
            case static_cast< uint32_t>(Literal::DCSMT_STATIC_CALIB_HIGH): return "DCSMT_STATIC_CALIB_HIGH";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocOutputEngineTypeT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            LOETT_UNKNOWN = 0,
            LOETT_FUSED = 1,
            LOETT_SPE = 2,
            LOETT_PPE = 3,
            LOETT_VPE = 4,
            LOETT_COUNT = 4
        };
    
        LocOutputEngineTypeT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::LOETT_UNKNOWN)) {}
        LocOutputEngineTypeT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::LOETT_UNKNOWN):
                case static_cast< uint8_t>(Literal::LOETT_FUSED):
                case static_cast< uint8_t>(Literal::LOETT_SPE):
                case static_cast< uint8_t>(Literal::LOETT_PPE):
                case static_cast< uint8_t>(Literal::LOETT_VPE):
                //case static_cast< uint8_t>(Literal::LOETT_COUNT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocOutputEngineTypeT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocOutputEngineTypeT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocOutputEngineTypeT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocOutputEngineTypeT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocOutputEngineTypeT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocOutputEngineTypeT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::LOETT_UNKNOWN): return "LOETT_UNKNOWN";
            case static_cast< uint8_t>(Literal::LOETT_FUSED): return "LOETT_FUSED";
            case static_cast< uint8_t>(Literal::LOETT_SPE): return "LOETT_SPE";
            case static_cast< uint8_t>(Literal::LOETT_PPE): return "LOETT_PPE";
            case static_cast< uint8_t>(Literal::LOETT_VPE): return "LOETT_VPE";
            //case static_cast< uint8_t>(Literal::LOETT_COUNT): return "LOETT_COUNT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct PositioningEngineMaskT : CommonAPI::Enumeration< uint16_t> {
        enum Literal : uint16_t {
            PEMT_UNKNOWN = 0,
            PEMT_STANDARD_POSITIONING_ENGINE = 1,
            PEMT_DEAD_RECKONING_ENGINE = 2,
            PEMT_PRECISE_POSITIONING_ENGINE = 4,
            PEMT_VP_POSITIONING_ENGINE = 8
        };
    
        PositioningEngineMaskT()
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(Literal::PEMT_UNKNOWN)) {}
        PositioningEngineMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint16_t>(Literal::PEMT_UNKNOWN):
                case static_cast< uint16_t>(Literal::PEMT_STANDARD_POSITIONING_ENGINE):
                case static_cast< uint16_t>(Literal::PEMT_DEAD_RECKONING_ENGINE):
                case static_cast< uint16_t>(Literal::PEMT_PRECISE_POSITIONING_ENGINE):
                case static_cast< uint16_t>(Literal::PEMT_VP_POSITIONING_ENGINE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositioningEngineMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositioningEngineMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositioningEngineMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositioningEngineMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositioningEngineMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositioningEngineMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint16_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint16_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint16_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint16_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint16_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint16_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint16_t>(Literal::PEMT_UNKNOWN): return "PEMT_UNKNOWN";
            case static_cast< uint16_t>(Literal::PEMT_STANDARD_POSITIONING_ENGINE): return "PEMT_STANDARD_POSITIONING_ENGINE";
            case static_cast< uint16_t>(Literal::PEMT_DEAD_RECKONING_ENGINE): return "PEMT_DEAD_RECKONING_ENGINE";
            case static_cast< uint16_t>(Literal::PEMT_PRECISE_POSITIONING_ENGINE): return "PEMT_PRECISE_POSITIONING_ENGINE";
            case static_cast< uint16_t>(Literal::PEMT_VP_POSITIONING_ENGINE): return "PEMT_VP_POSITIONING_ENGINE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DrSolutionStatusMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            DSSMT_UNKNOWN = 0,
            DSSMT_VEHICLE_SENSOR_SPEED_INPUT_DETECTED = 1,
            DSSMT_VEHICLE_SENSOR_SPEED_INPUT_USED = 2,
            DSSMT_WARNING_UNCALIBRATED = 4,
            DSSMT_WARNING_GNSS_QUALITY_INSUFFICIENT = 8,
            DSSMT_WARNING_FERRY_DETECTED = 16,
            DSSMT_ERROR_6DOF_SENSOR_UNAVAILABLE = 32,
            DSSMT_ERROR_VEHICLE_SPEED_UNAVAILABLE = 64,
            DSSMT_ERROR_GNSS_EPH_UNAVAILABLE = 128,
            DSSMT_ERROR_GNSS_MEAS_UNAVAILABLE = 256,
            DSSMT_WARNING_INIT_POSITION_INVALID = 512,
            DSSMT_WARNING_INIT_POSITION_UNRELIABLE = 1024,
            DSSMT_WARNING_POSITON_UNRELIABLE = 2048,
            DSSMT_ERROR_GENERIC = 4096,
            DSSMT_WARNING_SENSOR_TEMP_OUT_OF_RANGE = 8192,
            DSSMT_WARNING_USER_DYNAMICS_INSUFFICIENT = 16384,
            DSSMT_WARNING_FACTORY_DATA_INCONSISTENT = 32768,
            DSSMT_WARNING_MMF_UNAVAILABLE = 65536,
            DSSMT_WARNING_MMF_NOT_USABLE = 131072
        };
    
        DrSolutionStatusMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::DSSMT_UNKNOWN)) {}
        DrSolutionStatusMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::DSSMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::DSSMT_VEHICLE_SENSOR_SPEED_INPUT_DETECTED):
                case static_cast< uint32_t>(Literal::DSSMT_VEHICLE_SENSOR_SPEED_INPUT_USED):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_UNCALIBRATED):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_GNSS_QUALITY_INSUFFICIENT):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_FERRY_DETECTED):
                case static_cast< uint32_t>(Literal::DSSMT_ERROR_6DOF_SENSOR_UNAVAILABLE):
                case static_cast< uint32_t>(Literal::DSSMT_ERROR_VEHICLE_SPEED_UNAVAILABLE):
                case static_cast< uint32_t>(Literal::DSSMT_ERROR_GNSS_EPH_UNAVAILABLE):
                case static_cast< uint32_t>(Literal::DSSMT_ERROR_GNSS_MEAS_UNAVAILABLE):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_INIT_POSITION_INVALID):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_INIT_POSITION_UNRELIABLE):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_POSITON_UNRELIABLE):
                case static_cast< uint32_t>(Literal::DSSMT_ERROR_GENERIC):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_SENSOR_TEMP_OUT_OF_RANGE):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_USER_DYNAMICS_INSUFFICIENT):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_FACTORY_DATA_INCONSISTENT):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_MMF_UNAVAILABLE):
                case static_cast< uint32_t>(Literal::DSSMT_WARNING_MMF_NOT_USABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DrSolutionStatusMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DrSolutionStatusMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DrSolutionStatusMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DrSolutionStatusMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DrSolutionStatusMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DrSolutionStatusMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::DSSMT_UNKNOWN): return "DSSMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::DSSMT_VEHICLE_SENSOR_SPEED_INPUT_DETECTED): return "DSSMT_VEHICLE_SENSOR_SPEED_INPUT_DETECTED";
            case static_cast< uint32_t>(Literal::DSSMT_VEHICLE_SENSOR_SPEED_INPUT_USED): return "DSSMT_VEHICLE_SENSOR_SPEED_INPUT_USED";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_UNCALIBRATED): return "DSSMT_WARNING_UNCALIBRATED";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_GNSS_QUALITY_INSUFFICIENT): return "DSSMT_WARNING_GNSS_QUALITY_INSUFFICIENT";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_FERRY_DETECTED): return "DSSMT_WARNING_FERRY_DETECTED";
            case static_cast< uint32_t>(Literal::DSSMT_ERROR_6DOF_SENSOR_UNAVAILABLE): return "DSSMT_ERROR_6DOF_SENSOR_UNAVAILABLE";
            case static_cast< uint32_t>(Literal::DSSMT_ERROR_VEHICLE_SPEED_UNAVAILABLE): return "DSSMT_ERROR_VEHICLE_SPEED_UNAVAILABLE";
            case static_cast< uint32_t>(Literal::DSSMT_ERROR_GNSS_EPH_UNAVAILABLE): return "DSSMT_ERROR_GNSS_EPH_UNAVAILABLE";
            case static_cast< uint32_t>(Literal::DSSMT_ERROR_GNSS_MEAS_UNAVAILABLE): return "DSSMT_ERROR_GNSS_MEAS_UNAVAILABLE";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_INIT_POSITION_INVALID): return "DSSMT_WARNING_INIT_POSITION_INVALID";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_INIT_POSITION_UNRELIABLE): return "DSSMT_WARNING_INIT_POSITION_UNRELIABLE";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_POSITON_UNRELIABLE): return "DSSMT_WARNING_POSITON_UNRELIABLE";
            case static_cast< uint32_t>(Literal::DSSMT_ERROR_GENERIC): return "DSSMT_ERROR_GENERIC";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_SENSOR_TEMP_OUT_OF_RANGE): return "DSSMT_WARNING_SENSOR_TEMP_OUT_OF_RANGE";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_USER_DYNAMICS_INSUFFICIENT): return "DSSMT_WARNING_USER_DYNAMICS_INSUFFICIENT";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_FACTORY_DATA_INCONSISTENT): return "DSSMT_WARNING_FACTORY_DATA_INCONSISTENT";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_MMF_UNAVAILABLE): return "DSSMT_WARNING_MMF_UNAVAILABLE";
            case static_cast< uint32_t>(Literal::DSSMT_WARNING_MMF_NOT_USABLE): return "DSSMT_WARNING_MMF_NOT_USABLE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocationReportExtendedFlagMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            LREFMT_UNKNOWN = 0,
            LREFMT_ALTITUDE_ASSUMED = 1,
            LREFMT_SESSION_STATUS = 2,
            LREFMT_INTEGRITY_RISK_USED = 4,
            LREFMT_PROTECT_ALONG_TRACK = 8,
            LREFMT_PROTECT_CROSS_TRACK = 16,
            LREFMT_PROTECT_VERTICAL = 32,
            LREFMT_DGNSS_STATION_ID = 64,
            LREFMT_GPTP_TIME_BIT = 128,
            LREFMT_GPTP_TIME_UNC_BIT = 256,
            LREFMT_BASE_LINE_LENGTH_BIT = 512,
            LREFMT_AGE_OF_CORRECTION_BIT = 1024,
            LREFMT_REPORT_INTERVAL_BIT = 2048,
            LREFMT_LEAP_SECONDS_UNC_BIT = 4096
        };
    
        LocationReportExtendedFlagMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::LREFMT_UNKNOWN)) {}
        LocationReportExtendedFlagMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::LREFMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::LREFMT_ALTITUDE_ASSUMED):
                case static_cast< uint32_t>(Literal::LREFMT_SESSION_STATUS):
                case static_cast< uint32_t>(Literal::LREFMT_INTEGRITY_RISK_USED):
                case static_cast< uint32_t>(Literal::LREFMT_PROTECT_ALONG_TRACK):
                case static_cast< uint32_t>(Literal::LREFMT_PROTECT_CROSS_TRACK):
                case static_cast< uint32_t>(Literal::LREFMT_PROTECT_VERTICAL):
                case static_cast< uint32_t>(Literal::LREFMT_DGNSS_STATION_ID):
                case static_cast< uint32_t>(Literal::LREFMT_GPTP_TIME_BIT):
                case static_cast< uint32_t>(Literal::LREFMT_GPTP_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::LREFMT_BASE_LINE_LENGTH_BIT):
                case static_cast< uint32_t>(Literal::LREFMT_AGE_OF_CORRECTION_BIT):
                case static_cast< uint32_t>(Literal::LREFMT_REPORT_INTERVAL_BIT):
                case static_cast< uint32_t>(Literal::LREFMT_LEAP_SECONDS_UNC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocationReportExtendedFlagMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocationReportExtendedFlagMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocationReportExtendedFlagMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocationReportExtendedFlagMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocationReportExtendedFlagMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocationReportExtendedFlagMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::LREFMT_UNKNOWN): return "LREFMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::LREFMT_ALTITUDE_ASSUMED): return "LREFMT_ALTITUDE_ASSUMED";
            case static_cast< uint32_t>(Literal::LREFMT_SESSION_STATUS): return "LREFMT_SESSION_STATUS";
            case static_cast< uint32_t>(Literal::LREFMT_INTEGRITY_RISK_USED): return "LREFMT_INTEGRITY_RISK_USED";
            case static_cast< uint32_t>(Literal::LREFMT_PROTECT_ALONG_TRACK): return "LREFMT_PROTECT_ALONG_TRACK";
            case static_cast< uint32_t>(Literal::LREFMT_PROTECT_CROSS_TRACK): return "LREFMT_PROTECT_CROSS_TRACK";
            case static_cast< uint32_t>(Literal::LREFMT_PROTECT_VERTICAL): return "LREFMT_PROTECT_VERTICAL";
            case static_cast< uint32_t>(Literal::LREFMT_DGNSS_STATION_ID): return "LREFMT_DGNSS_STATION_ID";
            case static_cast< uint32_t>(Literal::LREFMT_GPTP_TIME_BIT): return "LREFMT_GPTP_TIME_BIT";
            case static_cast< uint32_t>(Literal::LREFMT_GPTP_TIME_UNC_BIT): return "LREFMT_GPTP_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::LREFMT_BASE_LINE_LENGTH_BIT): return "LREFMT_BASE_LINE_LENGTH_BIT";
            case static_cast< uint32_t>(Literal::LREFMT_AGE_OF_CORRECTION_BIT): return "LREFMT_AGE_OF_CORRECTION_BIT";
            case static_cast< uint32_t>(Literal::LREFMT_REPORT_INTERVAL_BIT): return "LREFMT_REPORT_INTERVAL_BIT";
            case static_cast< uint32_t>(Literal::LREFMT_LEAP_SECONDS_UNC_BIT): return "LREFMT_LEAP_SECONDS_UNC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct LocSessionStatusT : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            LSS_UNKNOWN = 0,
            LSS_SUCCESS = 1,
            LSS_INTERMEDIATE = 2,
            LSS_FAILURE = 3
        };
    
        LocSessionStatusT()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::LSS_UNKNOWN)) {}
        LocSessionStatusT(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::LSS_UNKNOWN):
                case static_cast< uint8_t>(Literal::LSS_SUCCESS):
                case static_cast< uint8_t>(Literal::LSS_INTERMEDIATE):
                case static_cast< uint8_t>(Literal::LSS_FAILURE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LocSessionStatusT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LocSessionStatusT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LocSessionStatusT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LocSessionStatusT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LocSessionStatusT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LocSessionStatusT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::LSS_UNKNOWN): return "LSS_UNKNOWN";
            case static_cast< uint8_t>(Literal::LSS_SUCCESS): return "LSS_SUCCESS";
            case static_cast< uint8_t>(Literal::LSS_INTERMEDIATE): return "LSS_INTERMEDIATE";
            case static_cast< uint8_t>(Literal::LSS_FAILURE): return "LSS_FAILURE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssSvOptionsMaskT : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            GSOMT_UNKNOWN = 0,
            GSOMT_HAS_EPHEMER_BIT = 1,
            GSOMT_HAS_ALMANAC_BIT = 2,
            GSOMT_HAS_USED_IN_FIX_BIT = 4,
            GSOMT_HAS_CARRIER_FREQ_BIT = 8,
            GSOMT_HAS_GNSS_SIGNAL_TYPE_BIT = 16,
            GSOMT_HAS_BASEBAND_CARRIER_TO_NOISE_BIT = 32,
            GSOMT_HAS_ELEVATION_BIT = 64,
            GSOMT_HAS_AZIMUTH_BIT = 128
        };
    
        GnssSvOptionsMaskT()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::GSOMT_UNKNOWN)) {}
        GnssSvOptionsMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::GSOMT_UNKNOWN):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_EPHEMER_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_ALMANAC_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_USED_IN_FIX_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_CARRIER_FREQ_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_GNSS_SIGNAL_TYPE_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_BASEBAND_CARRIER_TO_NOISE_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_ELEVATION_BIT):
                case static_cast< uint32_t>(Literal::GSOMT_HAS_AZIMUTH_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssSvOptionsMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssSvOptionsMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssSvOptionsMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssSvOptionsMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssSvOptionsMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssSvOptionsMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::GSOMT_UNKNOWN): return "GSOMT_UNKNOWN";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_EPHEMER_BIT): return "GSOMT_HAS_EPHEMER_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_ALMANAC_BIT): return "GSOMT_HAS_ALMANAC_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_USED_IN_FIX_BIT): return "GSOMT_HAS_USED_IN_FIX_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_CARRIER_FREQ_BIT): return "GSOMT_HAS_CARRIER_FREQ_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_GNSS_SIGNAL_TYPE_BIT): return "GSOMT_HAS_GNSS_SIGNAL_TYPE_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_BASEBAND_CARRIER_TO_NOISE_BIT): return "GSOMT_HAS_BASEBAND_CARRIER_TO_NOISE_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_ELEVATION_BIT): return "GSOMT_HAS_ELEVATION_BIT";
            case static_cast< uint32_t>(Literal::GSOMT_HAS_AZIMUTH_BIT): return "GSOMT_HAS_AZIMUTH_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct GnssDataMaskT : CommonAPI::Enumeration< uint16_t> {
        enum Literal : uint16_t {
            GDMT_UNKNOWN = 0,
            GDMT_JAMMER_IND_BIT = 1,
            GDMT_AGC_BIT = 2
        };
    
        GnssDataMaskT()
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(Literal::GDMT_UNKNOWN)) {}
        GnssDataMaskT(Literal _literal)
            : CommonAPI::Enumeration< uint16_t>(static_cast< uint16_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint16_t>(Literal::GDMT_UNKNOWN):
                case static_cast< uint16_t>(Literal::GDMT_JAMMER_IND_BIT):
                case static_cast< uint16_t>(Literal::GDMT_AGC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GnssDataMaskT &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GnssDataMaskT &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GnssDataMaskT &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GnssDataMaskT &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GnssDataMaskT &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GnssDataMaskT &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint16_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint16_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint16_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint16_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint16_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint16_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint16_t>(Literal::GDMT_UNKNOWN): return "GDMT_UNKNOWN";
            case static_cast< uint16_t>(Literal::GDMT_JAMMER_IND_BIT): return "GDMT_JAMMER_IND_BIT";
            case static_cast< uint16_t>(Literal::GDMT_AGC_BIT): return "GDMT_AGC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    struct MapMatchingFeedbackDataT : CommonAPI::Struct< uint32_t, uint64_t, double, double, float, double, float, float, float, bool> {
    
        MapMatchingFeedbackDataT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0.0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = false;
        }
        MapMatchingFeedbackDataT(const uint32_t &_validityMask, const uint64_t &_utcTimestampMs, const double &_mapMatchedLatitudeDifference, const double &_mapMatchedLongitudeDifference, const float &_bearing, const double &_altitude, const float &_horizontalAccuracy, const float &_altitudeAccuracy, const float &_bearingAccuracy, const bool &_isTunnel)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _utcTimestampMs;
            std::get< 2>(values_) = _mapMatchedLatitudeDifference;
            std::get< 3>(values_) = _mapMatchedLongitudeDifference;
            std::get< 4>(values_) = _bearing;
            std::get< 5>(values_) = _altitude;
            std::get< 6>(values_) = _horizontalAccuracy;
            std::get< 7>(values_) = _altitudeAccuracy;
            std::get< 8>(values_) = _bearingAccuracy;
            std::get< 9>(values_) = _isTunnel;
        }
        inline const uint32_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getUtcTimestampMs() const { return std::get< 1>(values_); }
        inline void setUtcTimestampMs(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const double &getMapMatchedLatitudeDifference() const { return std::get< 2>(values_); }
        inline void setMapMatchedLatitudeDifference(const double &_value) { std::get< 2>(values_) = _value; }
        inline const double &getMapMatchedLongitudeDifference() const { return std::get< 3>(values_); }
        inline void setMapMatchedLongitudeDifference(const double &_value) { std::get< 3>(values_) = _value; }
        inline const float &getBearing() const { return std::get< 4>(values_); }
        inline void setBearing(const float &_value) { std::get< 4>(values_) = _value; }
        inline const double &getAltitude() const { return std::get< 5>(values_); }
        inline void setAltitude(const double &_value) { std::get< 5>(values_) = _value; }
        inline const float &getHorizontalAccuracy() const { return std::get< 6>(values_); }
        inline void setHorizontalAccuracy(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getAltitudeAccuracy() const { return std::get< 7>(values_); }
        inline void setAltitudeAccuracy(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getBearingAccuracy() const { return std::get< 8>(values_); }
        inline void setBearingAccuracy(const float &_value) { std::get< 8>(values_) = _value; }
        inline const bool &getIsTunnel() const { return std::get< 9>(values_); }
        inline void setIsTunnel(const bool _value) { std::get< 9>(values_) = _value; }
        inline bool operator==(const MapMatchingFeedbackDataT& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getUtcTimestampMs() == _other.getUtcTimestampMs() && getMapMatchedLatitudeDifference() == _other.getMapMatchedLatitudeDifference() && getMapMatchedLongitudeDifference() == _other.getMapMatchedLongitudeDifference() && getBearing() == _other.getBearing() && getAltitude() == _other.getAltitude() && getHorizontalAccuracy() == _other.getHorizontalAccuracy() && getAltitudeAccuracy() == _other.getAltitudeAccuracy() && getBearingAccuracy() == _other.getBearingAccuracy() && getIsTunnel() == _other.getIsTunnel());
        }
        inline bool operator!=(const MapMatchingFeedbackDataT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationReportRequest : CommonAPI::Struct< uint32_t, uint32_t> {
    
        LocationReportRequest()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ul;
        }
        LocationReportRequest(const uint32_t &_intervalInMs, const uint32_t &_gnssReportCallbackMask)
        {
            std::get< 0>(values_) = _intervalInMs;
            std::get< 1>(values_) = _gnssReportCallbackMask;
        }
        inline const uint32_t &getIntervalInMs() const { return std::get< 0>(values_); }
        inline void setIntervalInMs(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getGnssReportCallbackMask() const { return std::get< 1>(values_); }
        inline void setGnssReportCallbackMask(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const LocationReportRequest& _other) const {
        return (getIntervalInMs() == _other.getIntervalInMs() && getGnssReportCallbackMask() == _other.getGnssReportCallbackMask());
        }
        inline bool operator!=(const LocationReportRequest &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationResponse : CommonAPI::Struct< LocationStatusT> {
    
        LocationResponse()
        {
            std::get< 0>(values_) = LocationStatusT();
        }
        LocationResponse(const LocationStatusT &_status)
        {
            std::get< 0>(values_) = _status;
        }
        inline const LocationStatusT &getStatus() const { return std::get< 0>(values_); }
        inline void setStatus(const LocationStatusT &_value) { std::get< 0>(values_) = _value; }
        inline bool operator==(const LocationResponse& _other) const {
        return (getStatus() == _other.getStatus());
        }
        inline bool operator!=(const LocationResponse &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct EngineSpecificLocationRequest : CommonAPI::Struct< uint32_t, uint32_t, uint32_t> {
    
        EngineSpecificLocationRequest()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = 0ul;
        }
        EngineSpecificLocationRequest(const uint32_t &_intervalInMs, const uint32_t &_locReqEngMask, const uint32_t &_engReportCallbackMask)
        {
            std::get< 0>(values_) = _intervalInMs;
            std::get< 1>(values_) = _locReqEngMask;
            std::get< 2>(values_) = _engReportCallbackMask;
        }
        inline const uint32_t &getIntervalInMs() const { return std::get< 0>(values_); }
        inline void setIntervalInMs(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getLocReqEngMask() const { return std::get< 1>(values_); }
        inline void setLocReqEngMask(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint32_t &getEngReportCallbackMask() const { return std::get< 2>(values_); }
        inline void setEngReportCallbackMask(const uint32_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const EngineSpecificLocationRequest& _other) const {
        return (getIntervalInMs() == _other.getIntervalInMs() && getLocReqEngMask() == _other.getLocReqEngMask() && getEngReportCallbackMask() == _other.getEngReportCallbackMask());
        }
        inline bool operator!=(const EngineSpecificLocationRequest &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationAidingDataDeletionMask : CommonAPI::Struct< uint32_t> {
    
        LocationAidingDataDeletionMask()
        {
            std::get< 0>(values_) = 0ul;
        }
        LocationAidingDataDeletionMask(const uint32_t &_deleteMask)
        {
            std::get< 0>(values_) = _deleteMask;
        }
        inline const uint32_t &getDeleteMask() const { return std::get< 0>(values_); }
        inline void setDeleteMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline bool operator==(const LocationAidingDataDeletionMask& _other) const {
        return (getDeleteMask() == _other.getDeleteMask());
        }
        inline bool operator!=(const LocationAidingDataDeletionMask &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssSvIdInfoT : CommonAPI::Struct< GnssConstellationTypeT, uint32_t> {
    
        GnssSvIdInfoT()
        {
            std::get< 0>(values_) = GnssConstellationTypeT();
            std::get< 1>(values_) = 0ul;
        }
        GnssSvIdInfoT(const GnssConstellationTypeT &_constellation, const uint32_t &_svId)
        {
            std::get< 0>(values_) = _constellation;
            std::get< 1>(values_) = _svId;
        }
        inline const GnssConstellationTypeT &getConstellation() const { return std::get< 0>(values_); }
        inline void setConstellation(const GnssConstellationTypeT &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getSvId() const { return std::get< 1>(values_); }
        inline void setSvId(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const GnssSvIdInfoT& _other) const {
        return (getConstellation() == _other.getConstellation() && getSvId() == _other.getSvId());
        }
        inline bool operator!=(const GnssSvIdInfoT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationGnssSvIdInfo : CommonAPI::Struct< std::vector< GnssSvIdInfoT >> {
    
        LocationGnssSvIdInfo()
        {
            std::get< 0>(values_) = std::vector< GnssSvIdInfoT >();
        }
        LocationGnssSvIdInfo(const std::vector< GnssSvIdInfoT > &_svList)
        {
            std::get< 0>(values_) = _svList;
        }
        inline const std::vector< GnssSvIdInfoT > &getSvList() const { return std::get< 0>(values_); }
        inline void setSvList(const std::vector< GnssSvIdInfoT > &_value) { std::get< 0>(values_) = _value; }
        inline bool operator==(const LocationGnssSvIdInfo& _other) const {
        return (getSvList() == _other.getSvList());
        }
        inline bool operator!=(const LocationGnssSvIdInfo &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationCapabilities : CommonAPI::Struct< uint32_t> {
    
        LocationCapabilities()
        {
            std::get< 0>(values_) = 0ul;
        }
        LocationCapabilities(const uint32_t &_capabilitiesMask)
        {
            std::get< 0>(values_) = _capabilitiesMask;
        }
        inline const uint32_t &getCapabilitiesMask() const { return std::get< 0>(values_); }
        inline void setCapabilitiesMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline bool operator==(const LocationCapabilities& _other) const {
        return (getCapabilitiesMask() == _other.getCapabilitiesMask());
        }
        inline bool operator!=(const LocationCapabilities &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssMeasurementsClockT : CommonAPI::Struct< uint32_t, int32_t, int64_t, double, int64_t, double, double, double, double, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t> {
    
        GnssMeasurementsClockT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0;
            std::get< 2>(values_) = 0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0;
            std::get< 5>(values_) = 0.0;
            std::get< 6>(values_) = 0.0;
            std::get< 7>(values_) = 0.0;
            std::get< 8>(values_) = 0.0;
            std::get< 9>(values_) = 0ul;
            std::get< 10>(values_) = 0ull;
            std::get< 11>(values_) = 0ull;
            std::get< 12>(values_) = 0ull;
            std::get< 13>(values_) = 0ull;
        }
        GnssMeasurementsClockT(const uint32_t &_flags, const int32_t &_leapSecond, const int64_t &_timeNs, const double &_timeUncertaintyNs, const int64_t &_fullBiasNs, const double &_biasNs, const double &_biasUncertaintyNs, const double &_driftNsps, const double &_driftUncertaintyNsps, const uint32_t &_hwClockDiscontinuityCount, const uint64_t &_elapsedRealTime, const uint64_t &_elapsedRealTimeUnc, const uint64_t &_elapsedgPtpTime, const uint64_t &_elapsedgPtpTimeUnc)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _leapSecond;
            std::get< 2>(values_) = _timeNs;
            std::get< 3>(values_) = _timeUncertaintyNs;
            std::get< 4>(values_) = _fullBiasNs;
            std::get< 5>(values_) = _biasNs;
            std::get< 6>(values_) = _biasUncertaintyNs;
            std::get< 7>(values_) = _driftNsps;
            std::get< 8>(values_) = _driftUncertaintyNsps;
            std::get< 9>(values_) = _hwClockDiscontinuityCount;
            std::get< 10>(values_) = _elapsedRealTime;
            std::get< 11>(values_) = _elapsedRealTimeUnc;
            std::get< 12>(values_) = _elapsedgPtpTime;
            std::get< 13>(values_) = _elapsedgPtpTimeUnc;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const int32_t &getLeapSecond() const { return std::get< 1>(values_); }
        inline void setLeapSecond(const int32_t &_value) { std::get< 1>(values_) = _value; }
        inline const int64_t &getTimeNs() const { return std::get< 2>(values_); }
        inline void setTimeNs(const int64_t &_value) { std::get< 2>(values_) = _value; }
        inline const double &getTimeUncertaintyNs() const { return std::get< 3>(values_); }
        inline void setTimeUncertaintyNs(const double &_value) { std::get< 3>(values_) = _value; }
        inline const int64_t &getFullBiasNs() const { return std::get< 4>(values_); }
        inline void setFullBiasNs(const int64_t &_value) { std::get< 4>(values_) = _value; }
        inline const double &getBiasNs() const { return std::get< 5>(values_); }
        inline void setBiasNs(const double &_value) { std::get< 5>(values_) = _value; }
        inline const double &getBiasUncertaintyNs() const { return std::get< 6>(values_); }
        inline void setBiasUncertaintyNs(const double &_value) { std::get< 6>(values_) = _value; }
        inline const double &getDriftNsps() const { return std::get< 7>(values_); }
        inline void setDriftNsps(const double &_value) { std::get< 7>(values_) = _value; }
        inline const double &getDriftUncertaintyNsps() const { return std::get< 8>(values_); }
        inline void setDriftUncertaintyNsps(const double &_value) { std::get< 8>(values_) = _value; }
        inline const uint32_t &getHwClockDiscontinuityCount() const { return std::get< 9>(values_); }
        inline void setHwClockDiscontinuityCount(const uint32_t &_value) { std::get< 9>(values_) = _value; }
        inline const uint64_t &getElapsedRealTime() const { return std::get< 10>(values_); }
        inline void setElapsedRealTime(const uint64_t &_value) { std::get< 10>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeUnc() const { return std::get< 11>(values_); }
        inline void setElapsedRealTimeUnc(const uint64_t &_value) { std::get< 11>(values_) = _value; }
        inline const uint64_t &getElapsedgPtpTime() const { return std::get< 12>(values_); }
        inline void setElapsedgPtpTime(const uint64_t &_value) { std::get< 12>(values_) = _value; }
        inline const uint64_t &getElapsedgPtpTimeUnc() const { return std::get< 13>(values_); }
        inline void setElapsedgPtpTimeUnc(const uint64_t &_value) { std::get< 13>(values_) = _value; }
        inline bool operator==(const GnssMeasurementsClockT& _other) const {
        return (getFlags() == _other.getFlags() && getLeapSecond() == _other.getLeapSecond() && getTimeNs() == _other.getTimeNs() && getTimeUncertaintyNs() == _other.getTimeUncertaintyNs() && getFullBiasNs() == _other.getFullBiasNs() && getBiasNs() == _other.getBiasNs() && getBiasUncertaintyNs() == _other.getBiasUncertaintyNs() && getDriftNsps() == _other.getDriftNsps() && getDriftUncertaintyNsps() == _other.getDriftUncertaintyNsps() && getHwClockDiscontinuityCount() == _other.getHwClockDiscontinuityCount() && getElapsedRealTime() == _other.getElapsedRealTime() && getElapsedRealTimeUnc() == _other.getElapsedRealTimeUnc() && getElapsedgPtpTime() == _other.getElapsedgPtpTime() && getElapsedgPtpTimeUnc() == _other.getElapsedgPtpTimeUnc());
        }
        inline bool operator!=(const GnssMeasurementsClockT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssMeasurementsDataT : CommonAPI::Struct< uint32_t, uint32_t, GnssSvTypeT, double, uint32_t, int64_t, float, int64_t, double, double, double, uint32_t, double, double, float, int64_t, double, double, uint32_t, double, double, double, GnssSignalTypeT, double, double, uint32_t> {
    
        GnssMeasurementsDataT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = GnssSvTypeT();
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0ul;
            std::get< 5>(values_) = 0;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0;
            std::get< 8>(values_) = 0.0;
            std::get< 9>(values_) = 0.0;
            std::get< 10>(values_) = 0.0;
            std::get< 11>(values_) = 0ul;
            std::get< 12>(values_) = 0.0;
            std::get< 13>(values_) = 0.0;
            std::get< 14>(values_) = 0.0f;
            std::get< 15>(values_) = 0;
            std::get< 16>(values_) = 0.0;
            std::get< 17>(values_) = 0.0;
            std::get< 18>(values_) = 0ul;
            std::get< 19>(values_) = 0.0;
            std::get< 20>(values_) = 0.0;
            std::get< 21>(values_) = 0.0;
            std::get< 22>(values_) = GnssSignalTypeT();
            std::get< 23>(values_) = 0.0;
            std::get< 24>(values_) = 0.0;
            std::get< 25>(values_) = 0ul;
        }
        GnssMeasurementsDataT(const uint32_t &_flags, const uint32_t &_svId, const GnssSvTypeT &_svType, const double &_timeOffsetNs, const uint32_t &_stateMask, const int64_t &_receivedSvTimeNs, const float &_receivedSvTimeSubNs, const int64_t &_receivedSvTimeUncertaintyNs, const double &_carrierToNoiseDbHz, const double &_pseudorangeRateMps, const double &_pseudorangeRateUncertaintyMps, const uint32_t &_adrStateMask, const double &_adrMeters, const double &_adrUncertaintyMeters, const float &_carrierFrequencyHz, const int64_t &_carrierCycles, const double &_carrierPhase, const double &_carrierPhaseUncertainty, const uint32_t &_multipathIndicator, const double &_signalToNoiseRatioDb, const double &_agcLevelDb, const double &_basebandCarrierToNoiseDbHz, const GnssSignalTypeT &_gnssSignalType, const double &_fullInterSignalBiasNs, const double &_fullInterSignalBiasUncertaintyNs, const uint32_t &_cycleSlipCount)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _svId;
            std::get< 2>(values_) = _svType;
            std::get< 3>(values_) = _timeOffsetNs;
            std::get< 4>(values_) = _stateMask;
            std::get< 5>(values_) = _receivedSvTimeNs;
            std::get< 6>(values_) = _receivedSvTimeSubNs;
            std::get< 7>(values_) = _receivedSvTimeUncertaintyNs;
            std::get< 8>(values_) = _carrierToNoiseDbHz;
            std::get< 9>(values_) = _pseudorangeRateMps;
            std::get< 10>(values_) = _pseudorangeRateUncertaintyMps;
            std::get< 11>(values_) = _adrStateMask;
            std::get< 12>(values_) = _adrMeters;
            std::get< 13>(values_) = _adrUncertaintyMeters;
            std::get< 14>(values_) = _carrierFrequencyHz;
            std::get< 15>(values_) = _carrierCycles;
            std::get< 16>(values_) = _carrierPhase;
            std::get< 17>(values_) = _carrierPhaseUncertainty;
            std::get< 18>(values_) = _multipathIndicator;
            std::get< 19>(values_) = _signalToNoiseRatioDb;
            std::get< 20>(values_) = _agcLevelDb;
            std::get< 21>(values_) = _basebandCarrierToNoiseDbHz;
            std::get< 22>(values_) = _gnssSignalType;
            std::get< 23>(values_) = _fullInterSignalBiasNs;
            std::get< 24>(values_) = _fullInterSignalBiasUncertaintyNs;
            std::get< 25>(values_) = _cycleSlipCount;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getSvId() const { return std::get< 1>(values_); }
        inline void setSvId(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const GnssSvTypeT &getSvType() const { return std::get< 2>(values_); }
        inline void setSvType(const GnssSvTypeT &_value) { std::get< 2>(values_) = _value; }
        inline const double &getTimeOffsetNs() const { return std::get< 3>(values_); }
        inline void setTimeOffsetNs(const double &_value) { std::get< 3>(values_) = _value; }
        inline const uint32_t &getStateMask() const { return std::get< 4>(values_); }
        inline void setStateMask(const uint32_t &_value) { std::get< 4>(values_) = _value; }
        inline const int64_t &getReceivedSvTimeNs() const { return std::get< 5>(values_); }
        inline void setReceivedSvTimeNs(const int64_t &_value) { std::get< 5>(values_) = _value; }
        inline const float &getReceivedSvTimeSubNs() const { return std::get< 6>(values_); }
        inline void setReceivedSvTimeSubNs(const float &_value) { std::get< 6>(values_) = _value; }
        inline const int64_t &getReceivedSvTimeUncertaintyNs() const { return std::get< 7>(values_); }
        inline void setReceivedSvTimeUncertaintyNs(const int64_t &_value) { std::get< 7>(values_) = _value; }
        inline const double &getCarrierToNoiseDbHz() const { return std::get< 8>(values_); }
        inline void setCarrierToNoiseDbHz(const double &_value) { std::get< 8>(values_) = _value; }
        inline const double &getPseudorangeRateMps() const { return std::get< 9>(values_); }
        inline void setPseudorangeRateMps(const double &_value) { std::get< 9>(values_) = _value; }
        inline const double &getPseudorangeRateUncertaintyMps() const { return std::get< 10>(values_); }
        inline void setPseudorangeRateUncertaintyMps(const double &_value) { std::get< 10>(values_) = _value; }
        inline const uint32_t &getAdrStateMask() const { return std::get< 11>(values_); }
        inline void setAdrStateMask(const uint32_t &_value) { std::get< 11>(values_) = _value; }
        inline const double &getAdrMeters() const { return std::get< 12>(values_); }
        inline void setAdrMeters(const double &_value) { std::get< 12>(values_) = _value; }
        inline const double &getAdrUncertaintyMeters() const { return std::get< 13>(values_); }
        inline void setAdrUncertaintyMeters(const double &_value) { std::get< 13>(values_) = _value; }
        inline const float &getCarrierFrequencyHz() const { return std::get< 14>(values_); }
        inline void setCarrierFrequencyHz(const float &_value) { std::get< 14>(values_) = _value; }
        inline const int64_t &getCarrierCycles() const { return std::get< 15>(values_); }
        inline void setCarrierCycles(const int64_t &_value) { std::get< 15>(values_) = _value; }
        inline const double &getCarrierPhase() const { return std::get< 16>(values_); }
        inline void setCarrierPhase(const double &_value) { std::get< 16>(values_) = _value; }
        inline const double &getCarrierPhaseUncertainty() const { return std::get< 17>(values_); }
        inline void setCarrierPhaseUncertainty(const double &_value) { std::get< 17>(values_) = _value; }
        inline const uint32_t &getMultipathIndicator() const { return std::get< 18>(values_); }
        inline void setMultipathIndicator(const uint32_t &_value) { std::get< 18>(values_) = _value; }
        inline const double &getSignalToNoiseRatioDb() const { return std::get< 19>(values_); }
        inline void setSignalToNoiseRatioDb(const double &_value) { std::get< 19>(values_) = _value; }
        inline const double &getAgcLevelDb() const { return std::get< 20>(values_); }
        inline void setAgcLevelDb(const double &_value) { std::get< 20>(values_) = _value; }
        inline const double &getBasebandCarrierToNoiseDbHz() const { return std::get< 21>(values_); }
        inline void setBasebandCarrierToNoiseDbHz(const double &_value) { std::get< 21>(values_) = _value; }
        inline const GnssSignalTypeT &getGnssSignalType() const { return std::get< 22>(values_); }
        inline void setGnssSignalType(const GnssSignalTypeT &_value) { std::get< 22>(values_) = _value; }
        inline const double &getFullInterSignalBiasNs() const { return std::get< 23>(values_); }
        inline void setFullInterSignalBiasNs(const double &_value) { std::get< 23>(values_) = _value; }
        inline const double &getFullInterSignalBiasUncertaintyNs() const { return std::get< 24>(values_); }
        inline void setFullInterSignalBiasUncertaintyNs(const double &_value) { std::get< 24>(values_) = _value; }
        inline const uint32_t &getCycleSlipCount() const { return std::get< 25>(values_); }
        inline void setCycleSlipCount(const uint32_t &_value) { std::get< 25>(values_) = _value; }
        inline bool operator==(const GnssMeasurementsDataT& _other) const {
        return (getFlags() == _other.getFlags() && getSvId() == _other.getSvId() && getSvType() == _other.getSvType() && getTimeOffsetNs() == _other.getTimeOffsetNs() && getStateMask() == _other.getStateMask() && getReceivedSvTimeNs() == _other.getReceivedSvTimeNs() && getReceivedSvTimeSubNs() == _other.getReceivedSvTimeSubNs() && getReceivedSvTimeUncertaintyNs() == _other.getReceivedSvTimeUncertaintyNs() && getCarrierToNoiseDbHz() == _other.getCarrierToNoiseDbHz() && getPseudorangeRateMps() == _other.getPseudorangeRateMps() && getPseudorangeRateUncertaintyMps() == _other.getPseudorangeRateUncertaintyMps() && getAdrStateMask() == _other.getAdrStateMask() && getAdrMeters() == _other.getAdrMeters() && getAdrUncertaintyMeters() == _other.getAdrUncertaintyMeters() && getCarrierFrequencyHz() == _other.getCarrierFrequencyHz() && getCarrierCycles() == _other.getCarrierCycles() && getCarrierPhase() == _other.getCarrierPhase() && getCarrierPhaseUncertainty() == _other.getCarrierPhaseUncertainty() && getMultipathIndicator() == _other.getMultipathIndicator() && getSignalToNoiseRatioDb() == _other.getSignalToNoiseRatioDb() && getAgcLevelDb() == _other.getAgcLevelDb() && getBasebandCarrierToNoiseDbHz() == _other.getBasebandCarrierToNoiseDbHz() && getGnssSignalType() == _other.getGnssSignalType() && getFullInterSignalBiasNs() == _other.getFullInterSignalBiasNs() && getFullInterSignalBiasUncertaintyNs() == _other.getFullInterSignalBiasUncertaintyNs() && getCycleSlipCount() == _other.getCycleSlipCount());
        }
        inline bool operator!=(const GnssMeasurementsDataT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssMeasurementsT : CommonAPI::Struct< GnssMeasurementsClockT, std::vector< GnssMeasurementsDataT >, bool, int32_t> {
    
        GnssMeasurementsT()
        {
            std::get< 0>(values_) = GnssMeasurementsClockT();
            std::get< 1>(values_) = std::vector< GnssMeasurementsDataT >();
            std::get< 2>(values_) = false;
            std::get< 3>(values_) = 0;
        }
        GnssMeasurementsT(const GnssMeasurementsClockT &_clock, const std::vector< GnssMeasurementsDataT > &_measurements, const bool &_isNHz, const int32_t &_reportingLatency)
        {
            std::get< 0>(values_) = _clock;
            std::get< 1>(values_) = _measurements;
            std::get< 2>(values_) = _isNHz;
            std::get< 3>(values_) = _reportingLatency;
        }
        inline const GnssMeasurementsClockT &getClock() const { return std::get< 0>(values_); }
        inline void setClock(const GnssMeasurementsClockT &_value) { std::get< 0>(values_) = _value; }
        inline const std::vector< GnssMeasurementsDataT > &getMeasurements() const { return std::get< 1>(values_); }
        inline void setMeasurements(const std::vector< GnssMeasurementsDataT > &_value) { std::get< 1>(values_) = _value; }
        inline const bool &getIsNHz() const { return std::get< 2>(values_); }
        inline void setIsNHz(const bool _value) { std::get< 2>(values_) = _value; }
        inline const int32_t &getReportingLatency() const { return std::get< 3>(values_); }
        inline void setReportingLatency(const int32_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const GnssMeasurementsT& _other) const {
        return (getClock() == _other.getClock() && getMeasurements() == _other.getMeasurements() && getIsNHz() == _other.getIsNHz() && getReportingLatency() == _other.getReportingLatency());
        }
        inline bool operator!=(const GnssMeasurementsT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationT : CommonAPI::Struct< uint32_t, uint64_t, double, double, double, float, float, float, float, float, float, uint32_t, uint64_t, uint64_t, float> {
    
        LocationT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0.0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0.0;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0.0f;
            std::get< 10>(values_) = 0.0f;
            std::get< 11>(values_) = 0ul;
            std::get< 12>(values_) = 0ull;
            std::get< 13>(values_) = 0ull;
            std::get< 14>(values_) = 0.0f;
        }
        LocationT(const uint32_t &_flags, const uint64_t &_timestamp, const double &_latitude, const double &_longitude, const double &_altitude, const float &_speed, const float &_bearing, const float &_horizontalAccuracy, const float &_verticalAccuracy, const float &_speedAccuracy, const float &_bearingAccuracy, const uint32_t &_techMask, const uint64_t &_elapsedRealTimeNs, const uint64_t &_elapsedRealTimeUncNs, const float &_timeUncMs)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _timestamp;
            std::get< 2>(values_) = _latitude;
            std::get< 3>(values_) = _longitude;
            std::get< 4>(values_) = _altitude;
            std::get< 5>(values_) = _speed;
            std::get< 6>(values_) = _bearing;
            std::get< 7>(values_) = _horizontalAccuracy;
            std::get< 8>(values_) = _verticalAccuracy;
            std::get< 9>(values_) = _speedAccuracy;
            std::get< 10>(values_) = _bearingAccuracy;
            std::get< 11>(values_) = _techMask;
            std::get< 12>(values_) = _elapsedRealTimeNs;
            std::get< 13>(values_) = _elapsedRealTimeUncNs;
            std::get< 14>(values_) = _timeUncMs;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getTimestamp() const { return std::get< 1>(values_); }
        inline void setTimestamp(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const double &getLatitude() const { return std::get< 2>(values_); }
        inline void setLatitude(const double &_value) { std::get< 2>(values_) = _value; }
        inline const double &getLongitude() const { return std::get< 3>(values_); }
        inline void setLongitude(const double &_value) { std::get< 3>(values_) = _value; }
        inline const double &getAltitude() const { return std::get< 4>(values_); }
        inline void setAltitude(const double &_value) { std::get< 4>(values_) = _value; }
        inline const float &getSpeed() const { return std::get< 5>(values_); }
        inline void setSpeed(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getBearing() const { return std::get< 6>(values_); }
        inline void setBearing(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getHorizontalAccuracy() const { return std::get< 7>(values_); }
        inline void setHorizontalAccuracy(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getVerticalAccuracy() const { return std::get< 8>(values_); }
        inline void setVerticalAccuracy(const float &_value) { std::get< 8>(values_) = _value; }
        inline const float &getSpeedAccuracy() const { return std::get< 9>(values_); }
        inline void setSpeedAccuracy(const float &_value) { std::get< 9>(values_) = _value; }
        inline const float &getBearingAccuracy() const { return std::get< 10>(values_); }
        inline void setBearingAccuracy(const float &_value) { std::get< 10>(values_) = _value; }
        inline const uint32_t &getTechMask() const { return std::get< 11>(values_); }
        inline void setTechMask(const uint32_t &_value) { std::get< 11>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeNs() const { return std::get< 12>(values_); }
        inline void setElapsedRealTimeNs(const uint64_t &_value) { std::get< 12>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeUncNs() const { return std::get< 13>(values_); }
        inline void setElapsedRealTimeUncNs(const uint64_t &_value) { std::get< 13>(values_) = _value; }
        inline const float &getTimeUncMs() const { return std::get< 14>(values_); }
        inline void setTimeUncMs(const float &_value) { std::get< 14>(values_) = _value; }
        inline bool operator==(const LocationT& _other) const {
        return (getFlags() == _other.getFlags() && getTimestamp() == _other.getTimestamp() && getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getAltitude() == _other.getAltitude() && getSpeed() == _other.getSpeed() && getBearing() == _other.getBearing() && getHorizontalAccuracy() == _other.getHorizontalAccuracy() && getVerticalAccuracy() == _other.getVerticalAccuracy() && getSpeedAccuracy() == _other.getSpeedAccuracy() && getBearingAccuracy() == _other.getBearingAccuracy() && getTechMask() == _other.getTechMask() && getElapsedRealTimeNs() == _other.getElapsedRealTimeNs() && getElapsedRealTimeUncNs() == _other.getElapsedRealTimeUncNs() && getTimeUncMs() == _other.getTimeUncMs());
        }
        inline bool operator!=(const LocationT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationReportSvUsedInPositionT : CommonAPI::Struct< uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t> {
    
        LocationReportSvUsedInPositionT()
        {
            std::get< 0>(values_) = 0ull;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0ull;
            std::get< 3>(values_) = 0ull;
            std::get< 4>(values_) = 0ull;
            std::get< 5>(values_) = 0ull;
        }
        LocationReportSvUsedInPositionT(const uint64_t &_gpsSvUsedIdsMask, const uint64_t &_gloSvUsedIdsMask, const uint64_t &_galSvUsedIdsMask, const uint64_t &_bdsSvUsedIdsMask, const uint64_t &_qzssSvUsedIdsMask, const uint64_t &_navicSvUsedIdsMask)
        {
            std::get< 0>(values_) = _gpsSvUsedIdsMask;
            std::get< 1>(values_) = _gloSvUsedIdsMask;
            std::get< 2>(values_) = _galSvUsedIdsMask;
            std::get< 3>(values_) = _bdsSvUsedIdsMask;
            std::get< 4>(values_) = _qzssSvUsedIdsMask;
            std::get< 5>(values_) = _navicSvUsedIdsMask;
        }
        inline const uint64_t &getGpsSvUsedIdsMask() const { return std::get< 0>(values_); }
        inline void setGpsSvUsedIdsMask(const uint64_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getGloSvUsedIdsMask() const { return std::get< 1>(values_); }
        inline void setGloSvUsedIdsMask(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint64_t &getGalSvUsedIdsMask() const { return std::get< 2>(values_); }
        inline void setGalSvUsedIdsMask(const uint64_t &_value) { std::get< 2>(values_) = _value; }
        inline const uint64_t &getBdsSvUsedIdsMask() const { return std::get< 3>(values_); }
        inline void setBdsSvUsedIdsMask(const uint64_t &_value) { std::get< 3>(values_) = _value; }
        inline const uint64_t &getQzssSvUsedIdsMask() const { return std::get< 4>(values_); }
        inline void setQzssSvUsedIdsMask(const uint64_t &_value) { std::get< 4>(values_) = _value; }
        inline const uint64_t &getNavicSvUsedIdsMask() const { return std::get< 5>(values_); }
        inline void setNavicSvUsedIdsMask(const uint64_t &_value) { std::get< 5>(values_) = _value; }
        inline bool operator==(const LocationReportSvUsedInPositionT& _other) const {
        return (getGpsSvUsedIdsMask() == _other.getGpsSvUsedIdsMask() && getGloSvUsedIdsMask() == _other.getGloSvUsedIdsMask() && getGalSvUsedIdsMask() == _other.getGalSvUsedIdsMask() && getBdsSvUsedIdsMask() == _other.getBdsSvUsedIdsMask() && getQzssSvUsedIdsMask() == _other.getQzssSvUsedIdsMask() && getNavicSvUsedIdsMask() == _other.getNavicSvUsedIdsMask());
        }
        inline bool operator!=(const LocationReportSvUsedInPositionT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationReportPositionDynamicsT : CommonAPI::Struct< uint32_t, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float> {
    
        LocationReportPositionDynamicsT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0.0f;
            std::get< 2>(values_) = 0.0f;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0.0f;
            std::get< 10>(values_) = 0.0f;
            std::get< 11>(values_) = 0.0f;
            std::get< 12>(values_) = 0.0f;
            std::get< 13>(values_) = 0.0f;
            std::get< 14>(values_) = 0.0f;
            std::get< 15>(values_) = 0.0f;
            std::get< 16>(values_) = 0.0f;
            std::get< 17>(values_) = 0.0f;
            std::get< 18>(values_) = 0.0f;
        }
        LocationReportPositionDynamicsT(const uint32_t &_bodyFrameDataMask, const float &_longAccel, const float &_latAccel, const float &_vertAccel, const float &_longAccelUnc, const float &_latAccelUnc, const float &_vertAccelUnc, const float &_pitch, const float &_pitchUnc, const float &_pitchRate, const float &_pitchRateUnc, const float &_roll, const float &_rollUnc, const float &_rollRate, const float &_rollRateUnc, const float &_yaw, const float &_yawUnc, const float &_yawRate, const float &_yawRateUnc)
        {
            std::get< 0>(values_) = _bodyFrameDataMask;
            std::get< 1>(values_) = _longAccel;
            std::get< 2>(values_) = _latAccel;
            std::get< 3>(values_) = _vertAccel;
            std::get< 4>(values_) = _longAccelUnc;
            std::get< 5>(values_) = _latAccelUnc;
            std::get< 6>(values_) = _vertAccelUnc;
            std::get< 7>(values_) = _pitch;
            std::get< 8>(values_) = _pitchUnc;
            std::get< 9>(values_) = _pitchRate;
            std::get< 10>(values_) = _pitchRateUnc;
            std::get< 11>(values_) = _roll;
            std::get< 12>(values_) = _rollUnc;
            std::get< 13>(values_) = _rollRate;
            std::get< 14>(values_) = _rollRateUnc;
            std::get< 15>(values_) = _yaw;
            std::get< 16>(values_) = _yawUnc;
            std::get< 17>(values_) = _yawRate;
            std::get< 18>(values_) = _yawRateUnc;
        }
        inline const uint32_t &getBodyFrameDataMask() const { return std::get< 0>(values_); }
        inline void setBodyFrameDataMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const float &getLongAccel() const { return std::get< 1>(values_); }
        inline void setLongAccel(const float &_value) { std::get< 1>(values_) = _value; }
        inline const float &getLatAccel() const { return std::get< 2>(values_); }
        inline void setLatAccel(const float &_value) { std::get< 2>(values_) = _value; }
        inline const float &getVertAccel() const { return std::get< 3>(values_); }
        inline void setVertAccel(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getLongAccelUnc() const { return std::get< 4>(values_); }
        inline void setLongAccelUnc(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getLatAccelUnc() const { return std::get< 5>(values_); }
        inline void setLatAccelUnc(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getVertAccelUnc() const { return std::get< 6>(values_); }
        inline void setVertAccelUnc(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getPitch() const { return std::get< 7>(values_); }
        inline void setPitch(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getPitchUnc() const { return std::get< 8>(values_); }
        inline void setPitchUnc(const float &_value) { std::get< 8>(values_) = _value; }
        inline const float &getPitchRate() const { return std::get< 9>(values_); }
        inline void setPitchRate(const float &_value) { std::get< 9>(values_) = _value; }
        inline const float &getPitchRateUnc() const { return std::get< 10>(values_); }
        inline void setPitchRateUnc(const float &_value) { std::get< 10>(values_) = _value; }
        inline const float &getRoll() const { return std::get< 11>(values_); }
        inline void setRoll(const float &_value) { std::get< 11>(values_) = _value; }
        inline const float &getRollUnc() const { return std::get< 12>(values_); }
        inline void setRollUnc(const float &_value) { std::get< 12>(values_) = _value; }
        inline const float &getRollRate() const { return std::get< 13>(values_); }
        inline void setRollRate(const float &_value) { std::get< 13>(values_) = _value; }
        inline const float &getRollRateUnc() const { return std::get< 14>(values_); }
        inline void setRollRateUnc(const float &_value) { std::get< 14>(values_) = _value; }
        inline const float &getYaw() const { return std::get< 15>(values_); }
        inline void setYaw(const float &_value) { std::get< 15>(values_) = _value; }
        inline const float &getYawUnc() const { return std::get< 16>(values_); }
        inline void setYawUnc(const float &_value) { std::get< 16>(values_) = _value; }
        inline const float &getYawRate() const { return std::get< 17>(values_); }
        inline void setYawRate(const float &_value) { std::get< 17>(values_) = _value; }
        inline const float &getYawRateUnc() const { return std::get< 18>(values_); }
        inline void setYawRateUnc(const float &_value) { std::get< 18>(values_) = _value; }
        inline bool operator==(const LocationReportPositionDynamicsT& _other) const {
        return (getBodyFrameDataMask() == _other.getBodyFrameDataMask() && getLongAccel() == _other.getLongAccel() && getLatAccel() == _other.getLatAccel() && getVertAccel() == _other.getVertAccel() && getLongAccelUnc() == _other.getLongAccelUnc() && getLatAccelUnc() == _other.getLatAccelUnc() && getVertAccelUnc() == _other.getVertAccelUnc() && getPitch() == _other.getPitch() && getPitchUnc() == _other.getPitchUnc() && getPitchRate() == _other.getPitchRate() && getPitchRateUnc() == _other.getPitchRateUnc() && getRoll() == _other.getRoll() && getRollUnc() == _other.getRollUnc() && getRollRate() == _other.getRollRate() && getRollRateUnc() == _other.getRollRateUnc() && getYaw() == _other.getYaw() && getYawUnc() == _other.getYawUnc() && getYawRate() == _other.getYawRate() && getYawRateUnc() == _other.getYawRateUnc());
        }
        inline bool operator!=(const LocationReportPositionDynamicsT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssSystemTimeStructTypeT : CommonAPI::Struct< uint32_t, uint32_t, uint32_t, float, float, uint32_t, uint32_t> {
    
        GnssSystemTimeStructTypeT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = 0ul;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0ul;
            std::get< 6>(values_) = 0ul;
        }
        GnssSystemTimeStructTypeT(const uint32_t &_validityMask, const uint32_t &_systemWeek, const uint32_t &_systemMsec, const float &_systemClkTimeBias, const float &_systemClkTimeUncMs, const uint32_t &_refFcount, const uint32_t &_numClockResets)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _systemWeek;
            std::get< 2>(values_) = _systemMsec;
            std::get< 3>(values_) = _systemClkTimeBias;
            std::get< 4>(values_) = _systemClkTimeUncMs;
            std::get< 5>(values_) = _refFcount;
            std::get< 6>(values_) = _numClockResets;
        }
        inline const uint32_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getSystemWeek() const { return std::get< 1>(values_); }
        inline void setSystemWeek(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint32_t &getSystemMsec() const { return std::get< 2>(values_); }
        inline void setSystemMsec(const uint32_t &_value) { std::get< 2>(values_) = _value; }
        inline const float &getSystemClkTimeBias() const { return std::get< 3>(values_); }
        inline void setSystemClkTimeBias(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getSystemClkTimeUncMs() const { return std::get< 4>(values_); }
        inline void setSystemClkTimeUncMs(const float &_value) { std::get< 4>(values_) = _value; }
        inline const uint32_t &getRefFcount() const { return std::get< 5>(values_); }
        inline void setRefFcount(const uint32_t &_value) { std::get< 5>(values_) = _value; }
        inline const uint32_t &getNumClockResets() const { return std::get< 6>(values_); }
        inline void setNumClockResets(const uint32_t &_value) { std::get< 6>(values_) = _value; }
        inline bool operator==(const GnssSystemTimeStructTypeT& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getSystemWeek() == _other.getSystemWeek() && getSystemMsec() == _other.getSystemMsec() && getSystemClkTimeBias() == _other.getSystemClkTimeBias() && getSystemClkTimeUncMs() == _other.getSystemClkTimeUncMs() && getRefFcount() == _other.getRefFcount() && getNumClockResets() == _other.getNumClockResets());
        }
        inline bool operator!=(const GnssSystemTimeStructTypeT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssGloTimeStructTypeT : CommonAPI::Struct< uint32_t, uint32_t, uint32_t, uint32_t, float, float, uint32_t, uint32_t> {
    
        GnssGloTimeStructTypeT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = 0ul;
            std::get< 3>(values_) = 0ul;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0ul;
            std::get< 7>(values_) = 0ul;
        }
        GnssGloTimeStructTypeT(const uint32_t &_validityMask, const uint32_t &_gloFourYear, const uint32_t &_gloDays, const uint32_t &_gloMsec, const float &_gloClkTimeBias, const float &_gloClkTimeUncMs, const uint32_t &_refFCount, const uint32_t &_numClockResets)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _gloFourYear;
            std::get< 2>(values_) = _gloDays;
            std::get< 3>(values_) = _gloMsec;
            std::get< 4>(values_) = _gloClkTimeBias;
            std::get< 5>(values_) = _gloClkTimeUncMs;
            std::get< 6>(values_) = _refFCount;
            std::get< 7>(values_) = _numClockResets;
        }
        inline const uint32_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getGloFourYear() const { return std::get< 1>(values_); }
        inline void setGloFourYear(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint32_t &getGloDays() const { return std::get< 2>(values_); }
        inline void setGloDays(const uint32_t &_value) { std::get< 2>(values_) = _value; }
        inline const uint32_t &getGloMsec() const { return std::get< 3>(values_); }
        inline void setGloMsec(const uint32_t &_value) { std::get< 3>(values_) = _value; }
        inline const float &getGloClkTimeBias() const { return std::get< 4>(values_); }
        inline void setGloClkTimeBias(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getGloClkTimeUncMs() const { return std::get< 5>(values_); }
        inline void setGloClkTimeUncMs(const float &_value) { std::get< 5>(values_) = _value; }
        inline const uint32_t &getRefFCount() const { return std::get< 6>(values_); }
        inline void setRefFCount(const uint32_t &_value) { std::get< 6>(values_) = _value; }
        inline const uint32_t &getNumClockResets() const { return std::get< 7>(values_); }
        inline void setNumClockResets(const uint32_t &_value) { std::get< 7>(values_) = _value; }
        inline bool operator==(const GnssGloTimeStructTypeT& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getGloFourYear() == _other.getGloFourYear() && getGloDays() == _other.getGloDays() && getGloMsec() == _other.getGloMsec() && getGloClkTimeBias() == _other.getGloClkTimeBias() && getGloClkTimeUncMs() == _other.getGloClkTimeUncMs() && getRefFCount() == _other.getRefFCount() && getNumClockResets() == _other.getNumClockResets());
        }
        inline bool operator!=(const GnssGloTimeStructTypeT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct SystemTimeStructT : CommonAPI::Struct< GnssSystemTimeStructTypeT, GnssGloTimeStructTypeT> {
    
        SystemTimeStructT()
        {
            std::get< 0>(values_) = GnssSystemTimeStructTypeT();
            std::get< 1>(values_) = GnssGloTimeStructTypeT();
        }
        SystemTimeStructT(const GnssSystemTimeStructTypeT &_gnssSystemTime, const GnssGloTimeStructTypeT &_gloSystemTime)
        {
            std::get< 0>(values_) = _gnssSystemTime;
            std::get< 1>(values_) = _gloSystemTime;
        }
        inline const GnssSystemTimeStructTypeT &getGnssSystemTime() const { return std::get< 0>(values_); }
        inline void setGnssSystemTime(const GnssSystemTimeStructTypeT &_value) { std::get< 0>(values_) = _value; }
        inline const GnssGloTimeStructTypeT &getGloSystemTime() const { return std::get< 1>(values_); }
        inline void setGloSystemTime(const GnssGloTimeStructTypeT &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const SystemTimeStructT& _other) const {
        return (getGnssSystemTime() == _other.getGnssSystemTime() && getGloSystemTime() == _other.getGloSystemTime());
        }
        inline bool operator!=(const SystemTimeStructT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssSystemTimeT : CommonAPI::Struct< GnssLocSvSystemTypeT, SystemTimeStructT> {
    
        GnssSystemTimeT()
        {
            std::get< 0>(values_) = GnssLocSvSystemTypeT();
            std::get< 1>(values_) = SystemTimeStructT();
        }
        GnssSystemTimeT(const GnssLocSvSystemTypeT &_gnssSystemTimeSrc, const SystemTimeStructT &_systemTime)
        {
            std::get< 0>(values_) = _gnssSystemTimeSrc;
            std::get< 1>(values_) = _systemTime;
        }
        inline const GnssLocSvSystemTypeT &getGnssSystemTimeSrc() const { return std::get< 0>(values_); }
        inline void setGnssSystemTimeSrc(const GnssLocSvSystemTypeT &_value) { std::get< 0>(values_) = _value; }
        inline const SystemTimeStructT &getSystemTime() const { return std::get< 1>(values_); }
        inline void setSystemTime(const SystemTimeStructT &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const GnssSystemTimeT& _other) const {
        return (getGnssSystemTimeSrc() == _other.getGnssSystemTimeSrc() && getSystemTime() == _other.getSystemTime());
        }
        inline bool operator!=(const GnssSystemTimeT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssMeasUsageInfoT : CommonAPI::Struct< GnssConstellationTypeT, uint32_t, GnssSignalTypeT> {
    
        GnssMeasUsageInfoT()
        {
            std::get< 0>(values_) = GnssConstellationTypeT();
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = GnssSignalTypeT();
        }
        GnssMeasUsageInfoT(const GnssConstellationTypeT &_gnssConstellation, const uint32_t &_gnssSvId, const GnssSignalTypeT &_gnssSignalType)
        {
            std::get< 0>(values_) = _gnssConstellation;
            std::get< 1>(values_) = _gnssSvId;
            std::get< 2>(values_) = _gnssSignalType;
        }
        inline const GnssConstellationTypeT &getGnssConstellation() const { return std::get< 0>(values_); }
        inline void setGnssConstellation(const GnssConstellationTypeT &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getGnssSvId() const { return std::get< 1>(values_); }
        inline void setGnssSvId(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const GnssSignalTypeT &getGnssSignalType() const { return std::get< 2>(values_); }
        inline void setGnssSignalType(const GnssSignalTypeT &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const GnssMeasUsageInfoT& _other) const {
        return (getGnssConstellation() == _other.getGnssConstellation() && getGnssSvId() == _other.getGnssSvId() && getGnssSignalType() == _other.getGnssSignalType());
        }
        inline bool operator!=(const GnssMeasUsageInfoT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LlaInfoT : CommonAPI::Struct< double, double, float> {
    
        LlaInfoT()
        {
            std::get< 0>(values_) = 0.0;
            std::get< 1>(values_) = 0.0;
            std::get< 2>(values_) = 0.0f;
        }
        LlaInfoT(const double &_latitude, const double &_longitude, const float &_altitude)
        {
            std::get< 0>(values_) = _latitude;
            std::get< 1>(values_) = _longitude;
            std::get< 2>(values_) = _altitude;
        }
        inline const double &getLatitude() const { return std::get< 0>(values_); }
        inline void setLatitude(const double &_value) { std::get< 0>(values_) = _value; }
        inline const double &getLongitude() const { return std::get< 1>(values_); }
        inline void setLongitude(const double &_value) { std::get< 1>(values_) = _value; }
        inline const float &getAltitude() const { return std::get< 2>(values_); }
        inline void setAltitude(const float &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const LlaInfoT& _other) const {
        return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getAltitude() == _other.getAltitude());
        }
        inline bool operator!=(const LlaInfoT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct LocationReportT : CommonAPI::Struct< LocationT, uint32_t, float, float, float, float, float, float, float, uint32_t, uint32_t, float, float, float, float, float, float, float, float, float, float, float, uint32_t, LocationReportSvUsedInPositionT, uint32_t, uint32_t, LocationReportPositionDynamicsT, GnssSystemTimeT, std::vector< GnssMeasUsageInfoT >, uint32_t, uint32_t, uint32_t, LocOutputEngineTypeT, uint32_t, float, LlaInfoT, std::vector< float >, uint32_t, uint32_t, bool, LocSessionStatusT, uint32_t, float, float, float, std::vector< uint32_t >, uint64_t, uint64_t, double, uint64_t, uint32_t, int32_t, uint32_t> {
    
        LocationReportT()
        {
            std::get< 0>(values_) = LocationT();
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = 0.0f;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0ul;
            std::get< 10>(values_) = 0ul;
            std::get< 11>(values_) = 0.0f;
            std::get< 12>(values_) = 0.0f;
            std::get< 13>(values_) = 0.0f;
            std::get< 14>(values_) = 0.0f;
            std::get< 15>(values_) = 0.0f;
            std::get< 16>(values_) = 0.0f;
            std::get< 17>(values_) = 0.0f;
            std::get< 18>(values_) = 0.0f;
            std::get< 19>(values_) = 0.0f;
            std::get< 20>(values_) = 0.0f;
            std::get< 21>(values_) = 0.0f;
            std::get< 22>(values_) = 0ul;
            std::get< 23>(values_) = LocationReportSvUsedInPositionT();
            std::get< 24>(values_) = 0ul;
            std::get< 25>(values_) = 0ul;
            std::get< 26>(values_) = LocationReportPositionDynamicsT();
            std::get< 27>(values_) = GnssSystemTimeT();
            std::get< 28>(values_) = std::vector< GnssMeasUsageInfoT >();
            std::get< 29>(values_) = 0ul;
            std::get< 30>(values_) = 0ul;
            std::get< 31>(values_) = 0ul;
            std::get< 32>(values_) = LocOutputEngineTypeT();
            std::get< 33>(values_) = 0ul;
            std::get< 34>(values_) = 0.0f;
            std::get< 35>(values_) = LlaInfoT();
            std::get< 36>(values_) = std::vector< float >();
            std::get< 37>(values_) = 0ul;
            std::get< 38>(values_) = 0ul;
            std::get< 39>(values_) = false;
            std::get< 40>(values_) = LocSessionStatusT();
            std::get< 41>(values_) = 0ul;
            std::get< 42>(values_) = 0.0f;
            std::get< 43>(values_) = 0.0f;
            std::get< 44>(values_) = 0.0f;
            std::get< 45>(values_) = std::vector< uint32_t >();
            std::get< 46>(values_) = 0ull;
            std::get< 47>(values_) = 0ull;
            std::get< 48>(values_) = 0.0;
            std::get< 49>(values_) = 0ull;
            std::get< 50>(values_) = 0ul;
            std::get< 51>(values_) = 0;
            std::get< 52>(values_) = 0ul;
        }
        LocationReportT(const LocationT &_locInfo, const uint32_t &_locationInfoFlags, const float &_altitudeMeanSeaLevel, const float &_pdop, const float &_hdop, const float &_vdop, const float &_gdop, const float &_tdop, const float &_magneticDeviation, const uint32_t &_horReliability, const uint32_t &_verReliability, const float &_horUncEllipseSemiMajor, const float &_horUncEllipseSemiMinor, const float &_horUncEllipseOrientAzimuth, const float &_northStdDeviation, const float &_eastStdDeviation, const float &_northVelocity, const float &_eastVelocity, const float &_upVelocity, const float &_northVelocityStdDeviation, const float &_eastVelocityStdDeviation, const float &_upVelocityStdDeviation, const uint32_t &_numSvUsedInPosition, const LocationReportSvUsedInPositionT &_svUsedInPosition, const uint32_t &_navSolutionMask, const uint32_t &_posTechMask, const LocationReportPositionDynamicsT &_bodyFrameData, const GnssSystemTimeT &_gnssSystemTime, const std::vector< GnssMeasUsageInfoT > &_measUsageInfo, const uint32_t &_leapSeconds, const uint32_t &_calibrationConfidencePercent, const uint32_t &_calibrationStatus, const LocOutputEngineTypeT &_locOutputEngType, const uint32_t &_locOutputEngMask, const float &_conformityIndex, const LlaInfoT &_llaVrpBased, const std::vector< float > &_enuVelocityVrpBased, const uint32_t &_drSolutionStatusMask, const uint32_t &_locationInfoExtendedFlags, const bool &_altitudeAssumed, const LocSessionStatusT &_sessionStatus, const uint32_t &_integrityRiskUsed, const float &_protectAlongTrack, const float &_protectCrossTrack, const float &_protectVertical, const std::vector< uint32_t > &_dgnssStationId, const uint64_t &_elapsedgPtpTime, const uint64_t &_elapsedgPtpTimeUnc, const double &_baseLineLength, const uint64_t &_ageMsecOfCorrections, const uint32_t &_posReportingInterval, const int32_t &_reportingLatency, const uint32_t &_leapSecondsUnc)
        {
            std::get< 0>(values_) = _locInfo;
            std::get< 1>(values_) = _locationInfoFlags;
            std::get< 2>(values_) = _altitudeMeanSeaLevel;
            std::get< 3>(values_) = _pdop;
            std::get< 4>(values_) = _hdop;
            std::get< 5>(values_) = _vdop;
            std::get< 6>(values_) = _gdop;
            std::get< 7>(values_) = _tdop;
            std::get< 8>(values_) = _magneticDeviation;
            std::get< 9>(values_) = _horReliability;
            std::get< 10>(values_) = _verReliability;
            std::get< 11>(values_) = _horUncEllipseSemiMajor;
            std::get< 12>(values_) = _horUncEllipseSemiMinor;
            std::get< 13>(values_) = _horUncEllipseOrientAzimuth;
            std::get< 14>(values_) = _northStdDeviation;
            std::get< 15>(values_) = _eastStdDeviation;
            std::get< 16>(values_) = _northVelocity;
            std::get< 17>(values_) = _eastVelocity;
            std::get< 18>(values_) = _upVelocity;
            std::get< 19>(values_) = _northVelocityStdDeviation;
            std::get< 20>(values_) = _eastVelocityStdDeviation;
            std::get< 21>(values_) = _upVelocityStdDeviation;
            std::get< 22>(values_) = _numSvUsedInPosition;
            std::get< 23>(values_) = _svUsedInPosition;
            std::get< 24>(values_) = _navSolutionMask;
            std::get< 25>(values_) = _posTechMask;
            std::get< 26>(values_) = _bodyFrameData;
            std::get< 27>(values_) = _gnssSystemTime;
            std::get< 28>(values_) = _measUsageInfo;
            std::get< 29>(values_) = _leapSeconds;
            std::get< 30>(values_) = _calibrationConfidencePercent;
            std::get< 31>(values_) = _calibrationStatus;
            std::get< 32>(values_) = _locOutputEngType;
            std::get< 33>(values_) = _locOutputEngMask;
            std::get< 34>(values_) = _conformityIndex;
            std::get< 35>(values_) = _llaVrpBased;
            std::get< 36>(values_) = _enuVelocityVrpBased;
            std::get< 37>(values_) = _drSolutionStatusMask;
            std::get< 38>(values_) = _locationInfoExtendedFlags;
            std::get< 39>(values_) = _altitudeAssumed;
            std::get< 40>(values_) = _sessionStatus;
            std::get< 41>(values_) = _integrityRiskUsed;
            std::get< 42>(values_) = _protectAlongTrack;
            std::get< 43>(values_) = _protectCrossTrack;
            std::get< 44>(values_) = _protectVertical;
            std::get< 45>(values_) = _dgnssStationId;
            std::get< 46>(values_) = _elapsedgPtpTime;
            std::get< 47>(values_) = _elapsedgPtpTimeUnc;
            std::get< 48>(values_) = _baseLineLength;
            std::get< 49>(values_) = _ageMsecOfCorrections;
            std::get< 50>(values_) = _posReportingInterval;
            std::get< 51>(values_) = _reportingLatency;
            std::get< 52>(values_) = _leapSecondsUnc;
        }
        inline const LocationT &getLocInfo() const { return std::get< 0>(values_); }
        inline void setLocInfo(const LocationT &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getLocationInfoFlags() const { return std::get< 1>(values_); }
        inline void setLocationInfoFlags(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const float &getAltitudeMeanSeaLevel() const { return std::get< 2>(values_); }
        inline void setAltitudeMeanSeaLevel(const float &_value) { std::get< 2>(values_) = _value; }
        inline const float &getPdop() const { return std::get< 3>(values_); }
        inline void setPdop(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getHdop() const { return std::get< 4>(values_); }
        inline void setHdop(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getVdop() const { return std::get< 5>(values_); }
        inline void setVdop(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getGdop() const { return std::get< 6>(values_); }
        inline void setGdop(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getTdop() const { return std::get< 7>(values_); }
        inline void setTdop(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getMagneticDeviation() const { return std::get< 8>(values_); }
        inline void setMagneticDeviation(const float &_value) { std::get< 8>(values_) = _value; }
        inline const uint32_t &getHorReliability() const { return std::get< 9>(values_); }
        inline void setHorReliability(const uint32_t &_value) { std::get< 9>(values_) = _value; }
        inline const uint32_t &getVerReliability() const { return std::get< 10>(values_); }
        inline void setVerReliability(const uint32_t &_value) { std::get< 10>(values_) = _value; }
        inline const float &getHorUncEllipseSemiMajor() const { return std::get< 11>(values_); }
        inline void setHorUncEllipseSemiMajor(const float &_value) { std::get< 11>(values_) = _value; }
        inline const float &getHorUncEllipseSemiMinor() const { return std::get< 12>(values_); }
        inline void setHorUncEllipseSemiMinor(const float &_value) { std::get< 12>(values_) = _value; }
        inline const float &getHorUncEllipseOrientAzimuth() const { return std::get< 13>(values_); }
        inline void setHorUncEllipseOrientAzimuth(const float &_value) { std::get< 13>(values_) = _value; }
        inline const float &getNorthStdDeviation() const { return std::get< 14>(values_); }
        inline void setNorthStdDeviation(const float &_value) { std::get< 14>(values_) = _value; }
        inline const float &getEastStdDeviation() const { return std::get< 15>(values_); }
        inline void setEastStdDeviation(const float &_value) { std::get< 15>(values_) = _value; }
        inline const float &getNorthVelocity() const { return std::get< 16>(values_); }
        inline void setNorthVelocity(const float &_value) { std::get< 16>(values_) = _value; }
        inline const float &getEastVelocity() const { return std::get< 17>(values_); }
        inline void setEastVelocity(const float &_value) { std::get< 17>(values_) = _value; }
        inline const float &getUpVelocity() const { return std::get< 18>(values_); }
        inline void setUpVelocity(const float &_value) { std::get< 18>(values_) = _value; }
        inline const float &getNorthVelocityStdDeviation() const { return std::get< 19>(values_); }
        inline void setNorthVelocityStdDeviation(const float &_value) { std::get< 19>(values_) = _value; }
        inline const float &getEastVelocityStdDeviation() const { return std::get< 20>(values_); }
        inline void setEastVelocityStdDeviation(const float &_value) { std::get< 20>(values_) = _value; }
        inline const float &getUpVelocityStdDeviation() const { return std::get< 21>(values_); }
        inline void setUpVelocityStdDeviation(const float &_value) { std::get< 21>(values_) = _value; }
        inline const uint32_t &getNumSvUsedInPosition() const { return std::get< 22>(values_); }
        inline void setNumSvUsedInPosition(const uint32_t &_value) { std::get< 22>(values_) = _value; }
        inline const LocationReportSvUsedInPositionT &getSvUsedInPosition() const { return std::get< 23>(values_); }
        inline void setSvUsedInPosition(const LocationReportSvUsedInPositionT &_value) { std::get< 23>(values_) = _value; }
        inline const uint32_t &getNavSolutionMask() const { return std::get< 24>(values_); }
        inline void setNavSolutionMask(const uint32_t &_value) { std::get< 24>(values_) = _value; }
        inline const uint32_t &getPosTechMask() const { return std::get< 25>(values_); }
        inline void setPosTechMask(const uint32_t &_value) { std::get< 25>(values_) = _value; }
        inline const LocationReportPositionDynamicsT &getBodyFrameData() const { return std::get< 26>(values_); }
        inline void setBodyFrameData(const LocationReportPositionDynamicsT &_value) { std::get< 26>(values_) = _value; }
        inline const GnssSystemTimeT &getGnssSystemTime() const { return std::get< 27>(values_); }
        inline void setGnssSystemTime(const GnssSystemTimeT &_value) { std::get< 27>(values_) = _value; }
        inline const std::vector< GnssMeasUsageInfoT > &getMeasUsageInfo() const { return std::get< 28>(values_); }
        inline void setMeasUsageInfo(const std::vector< GnssMeasUsageInfoT > &_value) { std::get< 28>(values_) = _value; }
        inline const uint32_t &getLeapSeconds() const { return std::get< 29>(values_); }
        inline void setLeapSeconds(const uint32_t &_value) { std::get< 29>(values_) = _value; }
        inline const uint32_t &getCalibrationConfidencePercent() const { return std::get< 30>(values_); }
        inline void setCalibrationConfidencePercent(const uint32_t &_value) { std::get< 30>(values_) = _value; }
        inline const uint32_t &getCalibrationStatus() const { return std::get< 31>(values_); }
        inline void setCalibrationStatus(const uint32_t &_value) { std::get< 31>(values_) = _value; }
        inline const LocOutputEngineTypeT &getLocOutputEngType() const { return std::get< 32>(values_); }
        inline void setLocOutputEngType(const LocOutputEngineTypeT &_value) { std::get< 32>(values_) = _value; }
        inline const uint32_t &getLocOutputEngMask() const { return std::get< 33>(values_); }
        inline void setLocOutputEngMask(const uint32_t &_value) { std::get< 33>(values_) = _value; }
        inline const float &getConformityIndex() const { return std::get< 34>(values_); }
        inline void setConformityIndex(const float &_value) { std::get< 34>(values_) = _value; }
        inline const LlaInfoT &getLlaVrpBased() const { return std::get< 35>(values_); }
        inline void setLlaVrpBased(const LlaInfoT &_value) { std::get< 35>(values_) = _value; }
        inline const std::vector< float > &getEnuVelocityVrpBased() const { return std::get< 36>(values_); }
        inline void setEnuVelocityVrpBased(const std::vector< float > &_value) { std::get< 36>(values_) = _value; }
        inline const uint32_t &getDrSolutionStatusMask() const { return std::get< 37>(values_); }
        inline void setDrSolutionStatusMask(const uint32_t &_value) { std::get< 37>(values_) = _value; }
        inline const uint32_t &getLocationInfoExtendedFlags() const { return std::get< 38>(values_); }
        inline void setLocationInfoExtendedFlags(const uint32_t &_value) { std::get< 38>(values_) = _value; }
        inline const bool &getAltitudeAssumed() const { return std::get< 39>(values_); }
        inline void setAltitudeAssumed(const bool _value) { std::get< 39>(values_) = _value; }
        inline const LocSessionStatusT &getSessionStatus() const { return std::get< 40>(values_); }
        inline void setSessionStatus(const LocSessionStatusT &_value) { std::get< 40>(values_) = _value; }
        inline const uint32_t &getIntegrityRiskUsed() const { return std::get< 41>(values_); }
        inline void setIntegrityRiskUsed(const uint32_t &_value) { std::get< 41>(values_) = _value; }
        inline const float &getProtectAlongTrack() const { return std::get< 42>(values_); }
        inline void setProtectAlongTrack(const float &_value) { std::get< 42>(values_) = _value; }
        inline const float &getProtectCrossTrack() const { return std::get< 43>(values_); }
        inline void setProtectCrossTrack(const float &_value) { std::get< 43>(values_) = _value; }
        inline const float &getProtectVertical() const { return std::get< 44>(values_); }
        inline void setProtectVertical(const float &_value) { std::get< 44>(values_) = _value; }
        inline const std::vector< uint32_t > &getDgnssStationId() const { return std::get< 45>(values_); }
        inline void setDgnssStationId(const std::vector< uint32_t > &_value) { std::get< 45>(values_) = _value; }
        inline const uint64_t &getElapsedgPtpTime() const { return std::get< 46>(values_); }
        inline void setElapsedgPtpTime(const uint64_t &_value) { std::get< 46>(values_) = _value; }
        inline const uint64_t &getElapsedgPtpTimeUnc() const { return std::get< 47>(values_); }
        inline void setElapsedgPtpTimeUnc(const uint64_t &_value) { std::get< 47>(values_) = _value; }
        inline const double &getBaseLineLength() const { return std::get< 48>(values_); }
        inline void setBaseLineLength(const double &_value) { std::get< 48>(values_) = _value; }
        inline const uint64_t &getAgeMsecOfCorrections() const { return std::get< 49>(values_); }
        inline void setAgeMsecOfCorrections(const uint64_t &_value) { std::get< 49>(values_) = _value; }
        inline const uint32_t &getPosReportingInterval() const { return std::get< 50>(values_); }
        inline void setPosReportingInterval(const uint32_t &_value) { std::get< 50>(values_) = _value; }
        inline const int32_t &getReportingLatency() const { return std::get< 51>(values_); }
        inline void setReportingLatency(const int32_t &_value) { std::get< 51>(values_) = _value; }
        inline const uint32_t &getLeapSecondsUnc() const { return std::get< 52>(values_); }
        inline void setLeapSecondsUnc(const uint32_t &_value) { std::get< 52>(values_) = _value; }
        inline bool operator==(const LocationReportT& _other) const {
        return (getLocInfo() == _other.getLocInfo() && getLocationInfoFlags() == _other.getLocationInfoFlags() && getAltitudeMeanSeaLevel() == _other.getAltitudeMeanSeaLevel() && getPdop() == _other.getPdop() && getHdop() == _other.getHdop() && getVdop() == _other.getVdop() && getGdop() == _other.getGdop() && getTdop() == _other.getTdop() && getMagneticDeviation() == _other.getMagneticDeviation() && getHorReliability() == _other.getHorReliability() && getVerReliability() == _other.getVerReliability() && getHorUncEllipseSemiMajor() == _other.getHorUncEllipseSemiMajor() && getHorUncEllipseSemiMinor() == _other.getHorUncEllipseSemiMinor() && getHorUncEllipseOrientAzimuth() == _other.getHorUncEllipseOrientAzimuth() && getNorthStdDeviation() == _other.getNorthStdDeviation() && getEastStdDeviation() == _other.getEastStdDeviation() && getNorthVelocity() == _other.getNorthVelocity() && getEastVelocity() == _other.getEastVelocity() && getUpVelocity() == _other.getUpVelocity() && getNorthVelocityStdDeviation() == _other.getNorthVelocityStdDeviation() && getEastVelocityStdDeviation() == _other.getEastVelocityStdDeviation() && getUpVelocityStdDeviation() == _other.getUpVelocityStdDeviation() && getNumSvUsedInPosition() == _other.getNumSvUsedInPosition() && getSvUsedInPosition() == _other.getSvUsedInPosition() && getNavSolutionMask() == _other.getNavSolutionMask() && getPosTechMask() == _other.getPosTechMask() && getBodyFrameData() == _other.getBodyFrameData() && getGnssSystemTime() == _other.getGnssSystemTime() && getMeasUsageInfo() == _other.getMeasUsageInfo() && getLeapSeconds() == _other.getLeapSeconds() && getCalibrationConfidencePercent() == _other.getCalibrationConfidencePercent() && getCalibrationStatus() == _other.getCalibrationStatus() && getLocOutputEngType() == _other.getLocOutputEngType() && getLocOutputEngMask() == _other.getLocOutputEngMask() && getConformityIndex() == _other.getConformityIndex() && getLlaVrpBased() == _other.getLlaVrpBased() && getEnuVelocityVrpBased() == _other.getEnuVelocityVrpBased() && getDrSolutionStatusMask() == _other.getDrSolutionStatusMask() && getLocationInfoExtendedFlags() == _other.getLocationInfoExtendedFlags() && getAltitudeAssumed() == _other.getAltitudeAssumed() && getSessionStatus() == _other.getSessionStatus() && getIntegrityRiskUsed() == _other.getIntegrityRiskUsed() && getProtectAlongTrack() == _other.getProtectAlongTrack() && getProtectCrossTrack() == _other.getProtectCrossTrack() && getProtectVertical() == _other.getProtectVertical() && getDgnssStationId() == _other.getDgnssStationId() && getElapsedgPtpTime() == _other.getElapsedgPtpTime() && getElapsedgPtpTimeUnc() == _other.getElapsedgPtpTimeUnc() && getBaseLineLength() == _other.getBaseLineLength() && getAgeMsecOfCorrections() == _other.getAgeMsecOfCorrections() && getPosReportingInterval() == _other.getPosReportingInterval() && getReportingLatency() == _other.getReportingLatency() && getLeapSecondsUnc() == _other.getLeapSecondsUnc());
        }
        inline bool operator!=(const LocationReportT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssSvDataT : CommonAPI::Struct< uint32_t, GnssSvTypeT, float, float, float, uint32_t, float, GnssSignalTypeT, double, uint32_t> {
    
        GnssSvDataT()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = GnssSvTypeT();
            std::get< 2>(values_) = 0.0f;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0ul;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = GnssSignalTypeT();
            std::get< 8>(values_) = 0.0;
            std::get< 9>(values_) = 0ul;
        }
        GnssSvDataT(const uint32_t &_svId, const GnssSvTypeT &_type, const float &_cN0DbHz, const float &_elevation, const float &_azimuth, const uint32_t &_gnssSvOptionsMask, const float &_carrierFrequencyHz, const GnssSignalTypeT &_gnssSignalType, const double &_basebandCarrierToNoiseDbHz, const uint32_t &_gloFrequency)
        {
            std::get< 0>(values_) = _svId;
            std::get< 1>(values_) = _type;
            std::get< 2>(values_) = _cN0DbHz;
            std::get< 3>(values_) = _elevation;
            std::get< 4>(values_) = _azimuth;
            std::get< 5>(values_) = _gnssSvOptionsMask;
            std::get< 6>(values_) = _carrierFrequencyHz;
            std::get< 7>(values_) = _gnssSignalType;
            std::get< 8>(values_) = _basebandCarrierToNoiseDbHz;
            std::get< 9>(values_) = _gloFrequency;
        }
        inline const uint32_t &getSvId() const { return std::get< 0>(values_); }
        inline void setSvId(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const GnssSvTypeT &getType() const { return std::get< 1>(values_); }
        inline void setType(const GnssSvTypeT &_value) { std::get< 1>(values_) = _value; }
        inline const float &getCN0DbHz() const { return std::get< 2>(values_); }
        inline void setCN0DbHz(const float &_value) { std::get< 2>(values_) = _value; }
        inline const float &getElevation() const { return std::get< 3>(values_); }
        inline void setElevation(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getAzimuth() const { return std::get< 4>(values_); }
        inline void setAzimuth(const float &_value) { std::get< 4>(values_) = _value; }
        inline const uint32_t &getGnssSvOptionsMask() const { return std::get< 5>(values_); }
        inline void setGnssSvOptionsMask(const uint32_t &_value) { std::get< 5>(values_) = _value; }
        inline const float &getCarrierFrequencyHz() const { return std::get< 6>(values_); }
        inline void setCarrierFrequencyHz(const float &_value) { std::get< 6>(values_) = _value; }
        inline const GnssSignalTypeT &getGnssSignalType() const { return std::get< 7>(values_); }
        inline void setGnssSignalType(const GnssSignalTypeT &_value) { std::get< 7>(values_) = _value; }
        inline const double &getBasebandCarrierToNoiseDbHz() const { return std::get< 8>(values_); }
        inline void setBasebandCarrierToNoiseDbHz(const double &_value) { std::get< 8>(values_) = _value; }
        inline const uint32_t &getGloFrequency() const { return std::get< 9>(values_); }
        inline void setGloFrequency(const uint32_t &_value) { std::get< 9>(values_) = _value; }
        inline bool operator==(const GnssSvDataT& _other) const {
        return (getSvId() == _other.getSvId() && getType() == _other.getType() && getCN0DbHz() == _other.getCN0DbHz() && getElevation() == _other.getElevation() && getAzimuth() == _other.getAzimuth() && getGnssSvOptionsMask() == _other.getGnssSvOptionsMask() && getCarrierFrequencyHz() == _other.getCarrierFrequencyHz() && getGnssSignalType() == _other.getGnssSignalType() && getBasebandCarrierToNoiseDbHz() == _other.getBasebandCarrierToNoiseDbHz() && getGloFrequency() == _other.getGloFrequency());
        }
        inline bool operator!=(const GnssSvDataT &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GnssDataT : CommonAPI::Struct< std::vector< uint32_t >, std::vector< double >, std::vector< double >> {
    
        GnssDataT()
        {
            std::get< 0>(values_) = std::vector< uint32_t >();
            std::get< 1>(values_) = std::vector< double >();
            std::get< 2>(values_) = std::vector< double >();
        }
        GnssDataT(const std::vector< uint32_t > &_gnssDataMask, const std::vector< double > &_jammerInd, const std::vector< double > &_agc)
        {
            std::get< 0>(values_) = _gnssDataMask;
            std::get< 1>(values_) = _jammerInd;
            std::get< 2>(values_) = _agc;
        }
        inline const std::vector< uint32_t > &getGnssDataMask() const { return std::get< 0>(values_); }
        inline void setGnssDataMask(const std::vector< uint32_t > &_value) { std::get< 0>(values_) = _value; }
        inline const std::vector< double > &getJammerInd() const { return std::get< 1>(values_); }
        inline void setJammerInd(const std::vector< double > &_value) { std::get< 1>(values_) = _value; }
        inline const std::vector< double > &getAgc() const { return std::get< 2>(values_); }
        inline void setAgc(const std::vector< double > &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const GnssDataT& _other) const {
        return (getGnssDataMask() == _other.getGnssDataMask() && getJammerInd() == _other.getJammerInd() && getAgc() == _other.getAgc());
        }
        inline bool operator!=(const GnssDataT &_other) const {
            return !((*this) == _other);
        }
    
    };


static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.qualcomm.qti.location.LocationTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct LocationTypes

} // namespace location
} // namespace qti
} // namespace qualcomm
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for MapMatchingFeedbackDataValidityT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::MapMatchingFeedbackDataValidityT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::MapMatchingFeedbackDataValidityT& mapMatchingFeedbackDataValidityT) const {
            return static_cast< uint32_t>(mapMatchingFeedbackDataValidityT);
        }
    };
    //Hash for GnssReportCbInfoMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssReportCbInfoMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssReportCbInfoMaskT& gnssReportCbInfoMaskT) const {
            return static_cast< uint32_t>(gnssReportCbInfoMaskT);
        }
    };
    //Hash for LocationStatusT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationStatusT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationStatusT& locationStatusT) const {
            return static_cast< uint8_t>(locationStatusT);
        }
    };
    //Hash for LocReqEngineTypeMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocReqEngineTypeMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocReqEngineTypeMaskT& locReqEngineTypeMaskT) const {
            return static_cast< uint16_t>(locReqEngineTypeMaskT);
        }
    };
    //Hash for EngineReportCbMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::EngineReportCbMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::EngineReportCbMaskT& engineReportCbMaskT) const {
            return static_cast< uint32_t>(engineReportCbMaskT);
        }
    };
    //Hash for AidingDataDeletionMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::AidingDataDeletionMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::AidingDataDeletionMaskT& aidingDataDeletionMaskT) const {
            return static_cast< uint32_t>(aidingDataDeletionMaskT);
        }
    };
    //Hash for GnssConstellationTypeT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssConstellationTypeT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssConstellationTypeT& gnssConstellationTypeT) const {
            return static_cast< uint8_t>(gnssConstellationTypeT);
        }
    };
    //Hash for LocationCapabilitiesMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationCapabilitiesMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationCapabilitiesMaskT& locationCapabilitiesMaskT) const {
            return static_cast< uint32_t>(locationCapabilitiesMaskT);
        }
    };
    //Hash for GnssMeasurementsClockFlagsMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsClockFlagsMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsClockFlagsMaskT& gnssMeasurementsClockFlagsMaskT) const {
            return static_cast< uint32_t>(gnssMeasurementsClockFlagsMaskT);
        }
    };
    //Hash for GnssMeasurementsDataFlagsMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsDataFlagsMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsDataFlagsMaskT& gnssMeasurementsDataFlagsMaskT) const {
            return static_cast< uint32_t>(gnssMeasurementsDataFlagsMaskT);
        }
    };
    //Hash for GnssSvTypeT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssSvTypeT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssSvTypeT& gnssSvTypeT) const {
            return static_cast< uint8_t>(gnssSvTypeT);
        }
    };
    //Hash for GnssMeasurementsStateMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsStateMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsStateMaskT& gnssMeasurementsStateMaskT) const {
            return static_cast< uint32_t>(gnssMeasurementsStateMaskT);
        }
    };
    //Hash for GnssMeasurementsAdrStateMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsAdrStateMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsAdrStateMaskT& gnssMeasurementsAdrStateMaskT) const {
            return static_cast< uint16_t>(gnssMeasurementsAdrStateMaskT);
        }
    };
    //Hash for GnssMeasurementsMultipathIndicatorT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsMultipathIndicatorT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssMeasurementsMultipathIndicatorT& gnssMeasurementsMultipathIndicatorT) const {
            return static_cast< uint16_t>(gnssMeasurementsMultipathIndicatorT);
        }
    };
    //Hash for GnssSignalTypeT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssSignalTypeT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssSignalTypeT& gnssSignalTypeT) const {
            return static_cast< uint32_t>(gnssSignalTypeT);
        }
    };
    //Hash for LocationFlagsMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationFlagsMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationFlagsMaskT& locationFlagsMaskT) const {
            return static_cast< uint32_t>(locationFlagsMaskT);
        }
    };
    //Hash for LocationTechnologyMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationTechnologyMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationTechnologyMaskT& locationTechnologyMaskT) const {
            return static_cast< uint32_t>(locationTechnologyMaskT);
        }
    };
    //Hash for LocationReportFlagMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportFlagMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportFlagMaskT& locationReportFlagMaskT) const {
            return static_cast< uint32_t>(locationReportFlagMaskT);
        }
    };
    //Hash for LocationReliabilityT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationReliabilityT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationReliabilityT& locationReliabilityT) const {
            return static_cast< uint8_t>(locationReliabilityT);
        }
    };
    //Hash for LocationReportNavSolutionMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportNavSolutionMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportNavSolutionMaskT& locationReportNavSolutionMaskT) const {
            return static_cast< uint32_t>(locationReportNavSolutionMaskT);
        }
    };
    //Hash for LocationReportPosDataMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportPosDataMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportPosDataMaskT& locationReportPosDataMaskT) const {
            return static_cast< uint32_t>(locationReportPosDataMaskT);
        }
    };
    //Hash for GnssLocSvSystemTypeT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssLocSvSystemTypeT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssLocSvSystemTypeT& gnssLocSvSystemTypeT) const {
            return static_cast< uint8_t>(gnssLocSvSystemTypeT);
        }
    };
    //Hash for GnssSystemTimeStructTypeFlagsT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssSystemTimeStructTypeFlagsT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssSystemTimeStructTypeFlagsT& gnssSystemTimeStructTypeFlagsT) const {
            return static_cast< uint32_t>(gnssSystemTimeStructTypeFlagsT);
        }
    };
    //Hash for GnssGloTimeStructTypeFlagsT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssGloTimeStructTypeFlagsT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssGloTimeStructTypeFlagsT& gnssGloTimeStructTypeFlagsT) const {
            return static_cast< uint32_t>(gnssGloTimeStructTypeFlagsT);
        }
    };
    //Hash for DrCalibrationStatusMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::DrCalibrationStatusMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::DrCalibrationStatusMaskT& drCalibrationStatusMaskT) const {
            return static_cast< uint32_t>(drCalibrationStatusMaskT);
        }
    };
    //Hash for LocOutputEngineTypeT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocOutputEngineTypeT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocOutputEngineTypeT& locOutputEngineTypeT) const {
            return static_cast< uint8_t>(locOutputEngineTypeT);
        }
    };
    //Hash for PositioningEngineMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::PositioningEngineMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::PositioningEngineMaskT& positioningEngineMaskT) const {
            return static_cast< uint16_t>(positioningEngineMaskT);
        }
    };
    //Hash for DrSolutionStatusMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::DrSolutionStatusMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::DrSolutionStatusMaskT& drSolutionStatusMaskT) const {
            return static_cast< uint32_t>(drSolutionStatusMaskT);
        }
    };
    //Hash for LocationReportExtendedFlagMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportExtendedFlagMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocationReportExtendedFlagMaskT& locationReportExtendedFlagMaskT) const {
            return static_cast< uint32_t>(locationReportExtendedFlagMaskT);
        }
    };
    //Hash for LocSessionStatusT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::LocSessionStatusT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::LocSessionStatusT& locSessionStatusT) const {
            return static_cast< uint8_t>(locSessionStatusT);
        }
    };
    //Hash for GnssSvOptionsMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssSvOptionsMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssSvOptionsMaskT& gnssSvOptionsMaskT) const {
            return static_cast< uint32_t>(gnssSvOptionsMaskT);
        }
    };
    //Hash for GnssDataMaskT
    template<>
    struct hash< ::v1::com::qualcomm::qti::location::LocationTypes::GnssDataMaskT> {
        inline size_t operator()(const ::v1::com::qualcomm::qti::location::LocationTypes::GnssDataMaskT& gnssDataMaskT) const {
            return static_cast< uint16_t>(gnssDataMaskT);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_QUALCOMM_QTI_LOCATION_Location_Types_HPP_
